{"pages":[],"posts":[{"title":"JS 原型链","text":"本文主要介绍了 JS 中的原型链以及一些个人对原型链的理解。 首先 pink 老师给的原型链如上图，有些小细节需要注意: prototype称为显示原型 __proto__ 称为隐式原型，ES6 之前不能直接操作隐式原型 Object.prototype instanceof Object的返回值是 false，但 typeof(Object.prototype) 返回值则是 object, 这是因为 instanceof 原理是查找前面的参数的原型链看是否有后面的参数的prototype，但是Object.prototype 继续查 __proto__ 只能查到 null，所以返回 false 再有 null 和 undefined 的区别，阮一峰博客里的说法是: null 表示”没有对象”，即该处不应该有值。 undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 个人理解是 null 相当于占位符，即考虑到了这个，也定义了，但他就不该有值，因此是 null；但 undefined 往往是压根就没考虑过这个值，即“未定义”。 还有就是打印 Object.prototype 得到结果如下： 压根找不到 __proto__:null 这一项，个人理解是单纯没有显示出来，因为尝试打印了一个乱码结果如下： 可以看到返回值是 undefined 而不是 null 而打印 Object.prototype.__proto__ 结果则是 null： 最后，关于 Object.__proto__, Object 作为 js 中的构造函数，那么它必然是个函数对象，既然是函数对象，那么它的隐式原型__proto__ 自然就是指向Function.prototype。 同理，任意一个构造函数的隐式原型都是 Function 的prototype 此外，Function 的 prototype 和 __proto__ 是一样的 所以最后原型链图我补充了一下：","link":"/2021/11/18/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"JS 的 class 中成员方法定义的小细节","text":"本文主要介绍了在 ES6 中新增的 class 中定义成员方法的三种方式, 以及各自的 this 指向问题。 在类里面定义成员方法有三种方式，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang='zh'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;meta http-equiv='X-UA-Compatible' content='IE=edge'&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; class Person { constructor(name) { this.name = name; } // 方式一 say() { console.log('this is say', this); } // 方式二 say2 = function (params) { console.log('this is say2', this); } // 方式三 say3 = () =&gt; { console.log('this is say3', this); } } console.dir(Person); var chen = new Person('chen'); console.log(chen); chen.say() chen.say2() chen.say3() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;chen.say&lt;/button&gt; &lt;button&gt;chen.say2&lt;/button&gt; &lt;button&gt;chen.say3&lt;/button&gt; &lt;script&gt; var bt = document.querySelectorAll('button'); bt[0].addEventListener('click', chen.say); bt[1].addEventListener('click', chen.say2); bt[2].addEventListener('click', chen.say3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 依次点击三个按钮后，控制台截图如下： 方法名后直接跟括号以及大括号，即上述的 say(){}。 这种方式定义的方法会放在类的原型对象 (Person.prototype ) 上，用类定义实例对象时并不会放到实例对象中。实例对象调用该方法时会通过原型链（ chen.__proto__ ）查找到类的原型对象上，从而找到该方法。方法中的 this 会指向调用该方法的对象。比如上例中的 chen.say() 是由实例对象 chen 调用，因此 this 指向 chen 。而当该方法最为按钮的点击事件被调用时， this 则会指向触发事件的按钮 bt。 say2 = function(){}。这种方式，我也不知道它把方法存在哪去了，反正打印 Person 类是找不到的，但是反正最后会直接放在实例对象中。这种方式定义的方法的 this 指向和上一种相同，就不多说了。 箭头函数方式，say3=()=&gt;{}。这种方式在 React 的类式组件中最常用了。方法体也是直接放在实例对象中。最大的特点是用了箭头函数，因此 this 指向的是定义方法的上下文的 this ，就结果而言，其实也就是类的实例对象。不管是谁调用，就算用 call() 和 bind()， this 指向都不会变。","link":"/2021/11/15/JS%E7%9A%84class%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"},{"title":"git push&#x2F;clone 操作失败的解决方法","text":"本文主要介绍自己之前遇到的 git push 和git clone总是失败的解决办法。 问题描述 之前刚开始尝试使用 git 操作的时候，git push 操作总是失败，一会报错是请求超时，一会报错是拒绝访问，然后最近刚开始写博客时，用到了 git clone，结果还是一样的问题。 之前也百度了很多方法，主要就三种： 修改 host 文件 关闭代理 忽略代理 我的确有开着代理，clash 一直在后台运行着。但实测无论开不开代理，开规则模式或者全局模式，网页都能正常访问 github，但是 git 操作就是死活不成功。然后使用 git 命令忽略代理，还是没效果。host 懒得改了，所以没试。总之都不行。 我试了有十几次，离谱的发现，报错还是随机的。在不开代理的情况下连续尝试了好几次git push，有几次是显示请求超时，有几次是拒绝访问，然后竟然还有那么一两次是可以成功的。反正当时我就这么类似卡 BUG 一样 勉强搞定了。 然后搭博客要用到git clone，不出所料依然一样的问题。这次又搜了搜，意外的发现还可以给 git 操作设置代理，然后就神奇的解决了……意外的很轻松呢，当时我可是纠结了几小时都没搞定啊。 解决方法 很简单，就给 git 设置代理就行了，命令如下： git config --global http.proxy &quot;localhost:port&quot; 这里的 port 端口是代理的端口，代理软件是 clash 的话，就是首页显示的这个 port。 然后就没有然后了。 当然，如果哪天不需要代理了，也可以用下面的命令关闭代理： git config --global --unset http.proxy ​ 其实到最后我也没搞清楚问题原因，个人猜测可能是 git push/clone 这两个操作请求的服务器被墙了吧，我这里宽带是联通的。至于为什么 github 网页能正常访问，emm，谁知道呢。 附上找到这个方法的文章链接： https://www.jianshu.com/p/471aeba64724","link":"/2021/11/18/git-push-clone%E6%93%8D%E4%BD%9C%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"hello hexo","text":"这是用 hexo 搭建博客后写的第一篇博文","link":"/2021/11/15/hello-hexo/"},{"title":"好客租房项目的小笔记 (一)","text":"本文主要介绍了 ES6 中新增的 async/await 的用法，顺便提及了 promise 的用法。 await 的知识点 await 其实只是替代了promise.then() 方法，但是还是没法省略掉 promise 对象。await 的后面必须跟一个 promise 对象，跟的是函数的话函数的返回值也要是 promise 对象。所以如果异步操作的函数里面没有返回 promise 对象，那还是得自己再包一层函数，将异步操作放在 return 的 promise 对象里才行。 比如 var data=await setTimeout(()={//...}) 是不行的，因为 await 后面跟的不是 promise 对象，需要写成: 12345678async function f3() { var data = await new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('time over') }, 500); }) console.log(data);} 注意 await 要用在函数里面，函数外侧需要有 async;还有就是 promise 内必须要调用 resolve() 或者 reject() 方法 总之, promise 是躲不掉的 原先接 promise 的返回值是要 promise.then((data)=&gt;{ //... }) 这样写就有点麻烦，用了 await 就成了： 12var data=await promise//... 可以看到 data 就直接拿到外面来了，下面再写对 data 的处理，这样看起来就像普通的同步操作一样，这也就是 await 最大的用处。 还有就是，async 函数的返回值是 Promise 对象，也就是说，await 后面可以直接跟一个用 async 修饰的函数。 Promise 对象内部也是单线程的，异步操作也是放在最后执行，所以 resolve() 不能直接写在异步操作外面，这样会先执行 resolve，后进行异步操作，自然会出问题 当然，即使 resolve 了 promise 内部的操作还会继续执行 比如： 1234567891011121314151617181920async function f5() { var data = await new Promise((resolve) =&gt; { data = 0 setTimeout(() =&gt; { console.log(' 异步操作 '); data = 1 }, 300); console.log(' 同步操作 '); resolve(data) }) console.log(' 外部操作 输出 data:', data);}f5() /* 结果：同步操作 外部操作 输出 data: 0异步操作*/ 可以看到首先执行了 promise 内部的同步操作，接着直接 resolve(data) ，外部在 resolve 后获取到了 data 值（未修改的）继续执行，输出了 data，最后 promise 内部的异步操作结束","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%B8%80/"},{"title":"好客租房项目的小笔记 (三)","text":"本文介绍了 react 中使用 onClick={} 绑定事件处理函数的几种情况。 关于 onClick={} 的问题 简单来说，有三种情况： 不需要传参，不需要获取触发事件的元素本身。这时直接写函数名即可，不需要使用箭头函数。 123function f(){}&lt;div onClick={f} /&gt; 切记千万不能写成 onClick={f()}，加了括号就会直接调用且只会调用一次。不加括号意味着是将函数体放在那。 不需要传参，但需要获取触发事件的元素本身。 12345function f(e){ //event.currentTarget 就是绑定的元素本身}&lt;div onClick={(e)=&gt;f(e)} /&gt; 需要注意的是，箭头函数的右侧不要写花括号，f(e) 是返回值，箭头函数只有返回值时可以同时省略 return 和 {} 。 或者也可以直接写成： 123function f(e){}&lt;div onClick={f} /&gt; 需要传参。 1234function f(){}let a=0&lt;div onClick={()=&gt;f(a)} /&gt; 参数的来源暂且不论，一般来说根据函数的闭包直接写 f(a) 即可","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%B8%89/"},{"title":"好客租房项目的小笔记 (二)","text":"本文主要介绍了 js 中 map() 和forEach()的区别以及为什么 react 要用map()。 关于 React 里面为什么渲染重复组件时用 map() 不用 forEach()首先，arr.map(callback()) 和 arr.forEach(callback()) 都可以遍历数组，二者区别在于，map() 会返回一个新的数组，而 forEach() 则不会。 先看一下项目里的用法吧： 12345678910111213141516171819202122232425renderTabItem() { return tabItems.map((item) =&gt; { return ( &lt;TabBar.Item //... &gt; &lt;/TabBar.Item&gt; ) })}//...render() { return ( &lt;div className=&quot;home&quot;&gt; //... &lt;TabBar&gt; { this.renderTabItem() } &lt;/TabBar&gt; &lt;/div&gt; )}} 以下是个人理解：既然是要渲染 dom 元素，那最后必然要有返回值才行。这里 map() 的回调函数中的 return ，实际上是返回了一个新数组中的一个个元素。也就是说，最后会得到一个元素为 JSX 节点的新数组，然后再经由最外侧的 return 返回给 render() 用于渲染组件（ JSX 会自己把数组中的元素一个个渲染出来）。 如果用 forEach() 的话，没有返回值，所以不行。","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%BA%8C/"},{"title":"好客租房项目的小笔记 (四)","text":"本文介绍了如何使用正则表达式进行 替换 特定文本。 正则替换 正则表达式除了用于查询之外，还可以用于替换。替换要用到圆括号 () 和 $。 圆括号表示捕获组的意思，本身并不影响匹配，但是在查询时可以实现查找重复内容。比如要查询字符串 abcd123+123efg 中的 123+123 部分，正则表达式可以写成：([0-9]+)\\+\\1 。其中，\\1就代表前面的 ([0-9]+) 匹配到的内容。要注意的是，匹配的是内容而不是正则表达式，也就是说，假如上述字符串为 abcd123+456efg ，那就没法匹配成功，因为 456 和 123 不一样，而 \\1 代表的的是前面的 ([0-9]+) 所匹配到的 123 , 而不是它自身。 接着话题回到替换上。替换基本上也是和上面一样，但是把反斜杠 \\ 换成了 $ , 用于表示要保留的内容（大概）。举个例子，要把 className={styles.mapContainer} 替换成 className='mapContainer' ，查找和替换的正则表达式可以这么写： 12classname=\\{styles.([A-Za-z0-9]+)\\} // 查找className='$1' // 替换 其中的 $1 就代表 ([A-Za-z0-9]+) 所匹配到的内容: mapContainer ，也就是想要保留的部分。要是有多个捕获组，当然也可以用 $2、$3 这类。个人觉得吧，替换的部分可能压根就不能用正则表达式，顶多只能像这样复用一下查找时匹配到的内容吧？ 高软老师的补充： 昨天课后讨论有关捕获组的用法，在匹配时仅适用于重复的字串，比如 219219219 或者 ABC ABC，这样的才能用 \\1 替代捕获组小括号里的匹配结果，在（）+ 这样将捕获组作为一个元素出现 1 次或多次的情况，\\1 代表最后一次匹配结果。 本文其实也用了这种方法替换中英文的逗号：匹配 ([\\u4e00-\\u9fa5]),([\\u4e00-\\u9fa5]) 替换为 $1，$2效果：汉字之间的英文逗号替换为中文逗号","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E5%9B%9B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"note","slug":"note","link":"/categories/note/"},{"name":"学习","slug":"note/学习","link":"/categories/note/%E5%AD%A6%E4%B9%A0/"}]}