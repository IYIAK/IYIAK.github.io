{"pages":[],"posts":[{"title":"JS 的 class 中成员方法定义的小细节","text":"本文主要介绍了在 ES6 中新增的 class 中定义成员方法的三种方式, 以及各自的 this 指向问题。 在类里面定义成员方法有三种方式，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang='zh'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;meta http-equiv='X-UA-Compatible' content='IE=edge'&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; class Person { constructor(name) { this.name = name; } // 方式一 say() { console.log('this is say', this); } // 方式二 say2 = function (params) { console.log('this is say2', this); } // 方式三 say3 = () =&gt; { console.log('this is say3', this); } } console.dir(Person); var chen = new Person('chen'); console.log(chen); chen.say() chen.say2() chen.say3() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;chen.say&lt;/button&gt; &lt;button&gt;chen.say2&lt;/button&gt; &lt;button&gt;chen.say3&lt;/button&gt; &lt;script&gt; var bt = document.querySelectorAll('button'); bt[0].addEventListener('click', chen.say); bt[1].addEventListener('click', chen.say2); bt[2].addEventListener('click', chen.say3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 依次点击三个按钮后，控制台截图如下： 方法名后直接跟括号以及大括号，即上述的 say(){}。 这种方式定义的方法会放在类的原型对象 (Person.prototype ) 上，用类定义实例对象时并不会放到实例对象中。实例对象调用该方法时会通过原型链（ chen.__proto__ ）查找到类的原型对象上，从而找到该方法。方法中的 this 会指向调用该方法的对象。比如上例中的 chen.say() 是由实例对象 chen 调用，因此 this 指向 chen 。而当该方法最为按钮的点击事件被调用时， this 则会指向触发事件的按钮 bt。 say2 = function(){}。这种方式，我也不知道它把方法存在哪去了，反正打印 Person 类是找不到的，但是反正最后会直接放在实例对象中。这种方式定义的方法的 this 指向和上一种相同，就不多说了。 箭头函数方式，say3=()=&gt;{}。这种方式在 React 的类式组件中最常用了。方法体也是直接放在实例对象中。最大的特点是用了箭头函数，因此 this 指向的是定义方法的上下文的 this ，就结果而言，其实也就是类的实例对象。不管是谁调用，就算用 call() 和 bind()， this 指向都不会变。","link":"/2021/11/15/JS%E7%9A%84class%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"},{"title":"JS 原型链","text":"本文主要介绍了 JS 中的原型链以及一些个人对原型链的理解。 首先 pink 老师给的原型链如上图，有些小细节需要注意: prototype称为显示原型 __proto__ 称为隐式原型，ES6 之前不能直接操作隐式原型 Object.prototype instanceof Object的返回值是 false，但 typeof(Object.prototype) 返回值则是 object, 这是因为 instanceof 原理是查找前面的参数的原型链看是否有后面的参数的prototype，但是Object.prototype 继续查 __proto__ 只能查到 null，所以返回 false 再有 null 和 undefined 的区别，阮一峰博客里的说法是: null 表示”没有对象”，即该处不应该有值。 undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 个人理解是 null 相当于占位符，即考虑到了这个，也定义了，但他就不该有值，因此是 null；但 undefined 往往是压根就没考虑过这个值，即“未定义”。 还有就是打印 Object.prototype 得到结果如下： 压根找不到 __proto__:null 这一项，个人理解是单纯没有显示出来，因为尝试打印了一个乱码结果如下： 可以看到返回值是 undefined 而不是 null 而打印 Object.prototype.__proto__ 结果则是 null： 最后，关于 Object.__proto__, Object 作为 js 中的构造函数，那么它必然是个函数对象，既然是函数对象，那么它的隐式原型__proto__ 自然就是指向Function.prototype。 同理，任意一个构造函数的隐式原型都是 Function 的prototype 此外，Function 的 prototype 和 __proto__ 是一样的 所以最后原型链图我补充了一下：","link":"/2021/11/18/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"git push&#x2F;clone 操作失败的解决方法","text":"本文主要介绍自己之前遇到的 git push 和git clone总是失败的解决办法。 问题描述 之前刚开始尝试使用 git 操作的时候，git push 操作总是失败，一会报错是请求超时，一会报错是拒绝访问，然后最近刚开始写博客时，用到了 git clone，结果还是一样的问题。 之前也百度了很多方法，主要就三种： 修改 host 文件 关闭代理 忽略代理 我的确有开着代理，clash 一直在后台运行着。但实测无论开不开代理，开规则模式或者全局模式，网页都能正常访问 github，但是 git 操作就是死活不成功。然后使用 git 命令忽略代理，还是没效果。host 懒得改了，所以没试。总之都不行。 我试了有十几次，离谱的发现，报错还是随机的。在不开代理的情况下连续尝试了好几次git push，有几次是显示请求超时，有几次是拒绝访问，然后竟然还有那么一两次是可以成功的。反正当时我就这么类似卡 BUG 一样 勉强搞定了。 然后搭博客要用到git clone，不出所料依然一样的问题。这次又搜了搜，意外的发现还可以给 git 操作设置代理，然后就神奇的解决了……意外的很轻松呢，当时我可是纠结了几小时都没搞定啊。 解决方法 很简单，就给 git 设置代理就行了，命令如下： git config --global http.proxy &quot;localhost:port&quot; 这里的 port 端口是代理的端口，代理软件是 clash 的话，就是首页显示的这个 port。 然后就没有然后了。 当然，如果哪天不需要代理了，也可以用下面的命令关闭代理： git config --global --unset http.proxy ​ 其实到最后我也没搞清楚问题原因，个人猜测可能是 git push/clone 这两个操作请求的服务器被墙了吧，我这里宽带是联通的。至于为什么 github 网页能正常访问，emm，谁知道呢。 附上找到这个方法的文章链接： https://www.jianshu.com/p/471aeba64724","link":"/2021/11/18/git-push-clone%E6%93%8D%E4%BD%9C%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"React 中 Hook 的简单使用","text":"本文简单介绍了 React 16.8 中新增的 State Hook 和 Effect Hook 的使用。 前言 以往用 React 做项目时，都会用类式组件来实现一些较为复杂的组件，函数式组件只能用于实现一些功能简单的组件。原因大概在于，函数式组件只能使用 props(作为函数的参数传入)，而不能像类式组件一样使用 state 和 refs。同时，类式组件还有生命周期钩子，比如常用的 componentDidMount() 和componentWillUnmount()，能够分别在组件挂载后和卸载前执行某些操作，函数式组件也没有。 但是类式组件也有它自身的很多问题，具体可以看React 官方文档，因此 React 在 16.8 版本中新增了 Hook。它可以在不编写 class 的情况下使用 state 以及其他的 React 特性。 Hook 的复杂运用我也不太会，但是还是可以说说最基本的两个 Hook：State Hook 和 Effect Hook。 State HookState Hook 是为了在函数式组件中使用 state 而设计的。以往在类式组件中，我们要用 state 得这么写： 12345678910111213141516import React, { Component } from 'react'export default class test extends Component { state={count:0} changeCount = () =&gt; { console.log(this.state.count) // 获取 count 并输出 this.setState({count:1}) // 修改 count } render() { return ( // ... ) }} 有了 State Hook，就可以这么写： 123456789101112131415import React，{useState} from 'react'export default function test() { const [count, setCount] = useState(0) changeCount = () =&gt; { console.log(count) // 获取 count 并输出 setCount(1) // 修改 count } return ( // ... )} 可以看到，定义 state 只需要 const [count, setCount] = useState(0)。这里用到了数组的解构赋值，具体来说，useState() 的返回值是一个有两个元素的数组，第一个元素就赋值给了 count，第二个元素就赋值给了setCount，要注意的是，这里的setCount 是一个用于修改对应 state 的函数。useState()的参数就是这个 state 的初值，比如这里就是给 count 赋初值 0。 使用 state 时就直接用 count 就行了，不用再麻烦的 this.state.count 了。修改 state 只需要调用该 state 对应的 setXXX() 就行，这里就是setCount(1)，括号里的参数就是要修改成的值。 但是要注意，setCount()不仅可以直接传值作为参数，也可以传函数作为参数，形如 setCount(count=&gt;count+1)。这里的 count 就是setCount() 对应的 state，虽然直接写 setCount(count+1) 也可以，但是如果是函数的形式，每次调用 setCount(count=&gt;count+1)，它都会自动获取到当前的最新的 count 值并传给子函数进行加一操作（其实是子函数返回的结果作为参数），如果用setCount(count+1) 的形式，这里的 count 其实是从上下文获取的，如果上下文的 count 不是直接就是对应的 state 而是通过参数传进来的话，可能会不能及时更新，导致 setCount() 结果不对。这里就不举例了，因为我也搞不懂啥时候会出错。总之，保险起见，用函数形式参数最安全，反正也就多敲几个字符而已，不是很麻烦。 12345678910function Demo(){ const [count, setCount] = useState(0) setInterval(()=&gt;{ console.log(count) setCount(count+1) },1000) return } 如果要多个 state，那就多用几次 useState() 就行，每次赋值给不同名称的参数即可。只要记住 state 都是两两成对，修改 state 必须用对应的方法就行。 Effect HookEffect Hook 又叫做副作用钩子，用于在函数组件中实现声明周期钩子的效果。 用法如下： 123456789101112131415161718import React, { useEffect}from 'react'export default function test() { useEffect(() =&gt; { // effect return () =&gt; { // cleanup } }, [deps]) return ( &lt;div&gt; &lt;/div&gt; )} useState()一个函数就能实现 componentDidMount() 、componentWillUnmount()、componentDidUpdate(prevProps, prevState) 三个函数的功能。 useState()的参数有两个，第一个是函数，第二个是数组。 写在函数体中的内容效果相当于 componentDidMount() 和componentDidUpdate()，也就是，组件每次更新就会执行一次，包括首次挂载时。函数的返回值也是一个函数，其中的效果与 componentWillUnmount() 相同，会在组件卸载前执行。 然后是第二个数组参数，也可以叫做“依赖数组（dependency array）”。 前面提到，函数体中的内容首次挂载和每次更新后都会执行，但这样就会有很多不必要的麻烦。比如：我想在函数首次挂载时发送 ajax 请求来获取数据。如果直接写在函数体中，则就会陷入：首次挂载 → 发送请求 → 数据更新 → 组件更新 → 发送请求 → 数据更新 → 组件更新 → … 的死循环。 而依赖就可以避免这个问题。函数体中的内容，只会在依赖数组中的值更新时才会调用，如果组件更新了但该数组中的元素的值并没有变化，则不会执行函数内容。 具体而言，可以看下面的例子： 12345678910111213141516171819202122232425262728import axios from 'axios'import React, { useState, useEffect } from 'react'export default function HookTest() { const [data, setData] = useState(null) const [count, setCount] = useState(0) async function getData(params) { const data = await axios.get('http://localhost:8080/home/swiper') console.log(data); setData(data.data.body); } // 第二个参数数组中的元素，应该最好是 state，因为只有 state 更新了才会请求重新渲染组件，从而利用第二个参数判断要不要重新渲染， // 如果不是 state，不管怎么修改都不会发起重新渲染的请求，也就没有意义了 // 如果只需要第一次挂载时执行，第二个参数设为[] 即可 useEffect(() =&gt; { getData(); }, [count]) return ( &lt;div&gt; &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt; 点我发送请求&lt;/button&gt; &lt;/div&gt; )} 这个例子就实现了 首次挂载时 以及 点击按钮后 发送请求的功能。 首次挂载必定会发送请求，这没什么好说的。重要的实现点击按钮发送请求且不会因为更新了 data 而更新组件继而又发送请求。 这里用到了名为 count 的 state： 点击按钮 → setCount(count + 1) → 修改了 state 从而更新组件 → 更新后 useEffect() 判断 count 是否和上一次的值相同 → 不同（加了 1），因此执行函数体内容，即发送请求 → 得到新数据，更新 data → data 也是 state，组件再次更新 → 但是这次 count 没变，因此不会再次执行函数体内容。 P.S. 我觉得一般情况下没人会像我上面那么写，正常做法应该是将发送请求单独写在一个函数里，然后在 useState() 第一个参数的函数体里调用一次，第二个参数数组设为[]，然后再单独给按钮的点击事件绑定这个函数。 Tips实测发现，如果不写useEffect()， 每次调用上一节定义的setCount()，函数组件都会更新一次，这跟类式组件差不多。但是，每次更新函数组件，它都会重新执行一遍其中的代码。 比如，如果函数里面写了一个setInterval()，且在该定时器里面调用了setCount()，那就会发现，每次更新组件都会多出一个计时器，计时器变多了组件更新的就更频繁，计时器增加的速度就更快，以此类推。 这肯定是不行的，所以这类只需要首次挂载时执行的代码，最好写在 useEffect 里，并且将依赖数组设为空数组（但是写空数组 react 会警告，所以干脆直接不写第二个参数即可）。 自定义 Hook自定义 hook 的目的往往是为了将可以复用的逻辑代码从组件中抽离出来，单独封装为一个 Hook。 Hook 只能在 react 函数的最顶层使用，而 react 函数就只有两种：函数式组件以及自定义 hook。为了能够让 react 判断我们自己定义的函数是自定义 hook，避免报错，自定义 hook 的函数名必须以 use 开头，形如 useXxx 的形式。 下面以封装 useState() 和useEffect()为例，见到那介绍一下自定义 hook 的用法。 封装 useState() 上面介绍 useState() 时，写了如下的代码： 1234567891011121314import React，{useState} from 'react'export default function test() { const [count, setCount] = useState(0) changeCount = () =&gt; { console.log(count) // 获取 count 并输出 setCount(1) // 修改 count } return ( // ... )} 其中的 changeCount() 就是逻辑代码，可以按如下方式抽离出来： 123456789101112131415161718192021import React，{useState} from 'react'function useCount(initValue){ const [count, setCount] = useState(initValue) changeCount = () =&gt; { console.log(count) // 获取 count 并输出 setCount(1) // 修改 count } return [count,changeCount]}export default function test() { const [count,setCount] = useCount(0) return ( // ... // 此处直接调用 setCount() 就能实现将 count 变为 1 )} 这样封装后，组件中就不需要考虑要怎么处理 count 数据，只需要调用 setCount() 即可。如果有多个组件需要这要操作 count，只需调用该 hook 即可，这样就实现了复用。同时，在同一个组件中也可以多次调用上面定义的useCount(), 每次调用后产生的 count 互相独立，互不影响，只需要在组件里用不同的变量名来接就行了，比如 count1、count2 之类。 封装 useEffect() 封装 useEffect() 的操作其实也差不多： 123456789101112131415161718192021import React, { useEffect}from 'react'function useMyeffect(){ useEffect(() =&gt; { // effect return () =&gt; { // cleanup } }, [input])}export default function test() { useMyeffect() return ( &lt;div&gt; &lt;/div&gt; )} 上面就是最简单的封装了useEffect()，可以简单的实现代码复用。 当然，一般应该不会这么简单吧，比如 react 官方文档 就同时封装了 useState() 和useEffect()在一个 hook 中。就我自己举的例子里，其实也可以传一些参数给useMyeffect()，甚至可以直接传一个函数进去，在内部调用，这样能实现的功能就更多了。但是，这毕竟只是最简单的一个例子而已，简简单单才好理解嘛。 自定义 hook 中 useEffect() 的执行时机 封装了 useEffect(), 很自然的就会有一个问题：自定义 hook 中的useEffect()，它的各个部分的执行时机是什么时候？我是谷歌搜了半天都没看到有确切的回答。但是注意到，react 官方文档中的例子里，封装useEffect() 的时候，是原封不动的把原先组件中的代码复制进去的，只在最后添加了一个 return。既然原封不动的拷贝都不会改变组件的功能，那自然，封装之后的 useEffect() 执行时机肯定和直接写在组件里相同。 结尾Hooks 应该是大势所趋吧，但肯定不可能就我上面写的那么点内容。之后还是要多研究研究才行。 附：React 官方文档","link":"/2021/11/19/React%E4%B8%ADHook%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"hello hexo","text":"这是用 hexo 搭建博客后写的第一篇博文","link":"/2021/11/15/hello-hexo/"},{"title":"hexo deploy 执行失败的解决方法","text":"为了能上传这篇文章浪费了两个多小时。 问题描述 hexo deploy 突然没法执行成功了，报错如下： 很明显是 git 操作又出了问题，看描述是没有写权限。 百度了半天，全是说用户名密码出了问题，重新设置一下就好。但是一点用都没有。还有说获取个 token 就行的，试了也没用，报错还变了： 总之将近两小时一事无成。 解决方法 换用 ssh，不用 https 了。 首先要获取一个 ssh，教程在这，只要看怎么获取 SSH Key 并绑定到 github 上就行了。 然后复制仓库的 ssh 地址： 再粘贴到 hexo 的 _config.yml 中，位置及格式如下（branch 可有可无）： 然后就 OK 啦，直接 hexo deploy 就行了。","link":"/2021/11/19/hexo-deploy%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"好客租房项目的小笔记 (三)","text":"本文介绍了 react 中使用 onClick={} 绑定事件处理函数的几种情况。 关于 onClick={} 的问题 简单来说，有三种情况： 不需要传参，不需要获取触发事件的元素本身。这时直接写函数名即可，不需要使用箭头函数。 123function f(){}&lt;div onClick={f} /&gt; 切记千万不能写成 onClick={f()}，加了括号就会直接调用且只会调用一次。不加括号意味着是将函数体放在那。 不需要传参，但需要获取触发事件的元素本身。 12345function f(e){ //event.currentTarget 就是绑定的元素本身}&lt;div onClick={(e)=&gt;f(e)} /&gt; 需要注意的是，箭头函数的右侧不要写花括号，f(e) 是返回值，箭头函数只有返回值时可以同时省略 return 和 {} 。 或者也可以直接写成： 123function f(e){}&lt;div onClick={f} /&gt; 需要传参。 1234function f(){}let a=0&lt;div onClick={()=&gt;f(a)} /&gt; 参数的来源暂且不论，一般来说根据函数的闭包直接写 f(a) 即可","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%B8%89/"},{"title":"好客租房项目的小笔记 (一)","text":"本文主要介绍了 ES6 中新增的 async/await 的用法，顺便提及了 promise 的用法。 await 的知识点 await 其实只是替代了promise.then() 方法，但是还是没法省略掉 promise 对象。await 的后面必须跟一个 promise 对象，跟的是函数的话函数的返回值也要是 promise 对象。所以如果异步操作的函数里面没有返回 promise 对象，那还是得自己再包一层函数，将异步操作放在 return 的 promise 对象里才行。 比如 var data=await setTimeout(()={//...}) 是不行的，因为 await 后面跟的不是 promise 对象，需要写成: 12345678async function f3() { var data = await new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('time over') }, 500); }) console.log(data);} 注意 await 要用在函数里面，函数外侧需要有 async;还有就是 promise 内必须要调用 resolve() 或者 reject() 方法 总之, promise 是躲不掉的 原先接 promise 的返回值是要 promise.then((data)=&gt;{ //... }) 这样写就有点麻烦，用了 await 就成了： 12var data=await promise//... 可以看到 data 就直接拿到外面来了，下面再写对 data 的处理，这样看起来就像普通的同步操作一样，这也就是 await 最大的用处。 还有就是，async 函数的返回值是 Promise 对象，也就是说，await 后面可以直接跟一个用 async 修饰的函数。 Promise 对象内部也是单线程的，异步操作也是放在最后执行，所以 resolve() 不能直接写在异步操作外面，这样会先执行 resolve，后进行异步操作，自然会出问题 当然，即使 resolve 了 promise 内部的操作还会继续执行 比如： 1234567891011121314151617181920async function f5() { var data = await new Promise((resolve) =&gt; { data = 0 setTimeout(() =&gt; { console.log(' 异步操作 '); data = 1 }, 300); console.log(' 同步操作 '); resolve(data) }) console.log(' 外部操作 输出 data:', data);}f5() /* 结果：同步操作 外部操作 输出 data: 0异步操作*/ 可以看到首先执行了 promise 内部的同步操作，接着直接 resolve(data) ，外部在 resolve 后获取到了 data 值（未修改的）继续执行，输出了 data，最后 promise 内部的异步操作结束","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%B8%80/"},{"title":"好客租房项目的小笔记 (四)","text":"本文介绍了如何使用正则表达式进行 替换 特定文本。 正则替换 正则表达式除了用于查询之外，还可以用于替换。替换要用到圆括号 () 和 $。 圆括号表示捕获组的意思，本身并不影响匹配，但是在查询时可以实现查找重复内容。比如要查询字符串 abcd123+123efg 中的 123+123 部分，正则表达式可以写成：([0-9]+)\\+\\1 。其中，\\1就代表前面的 ([0-9]+) 匹配到的内容。要注意的是，匹配的是内容而不是正则表达式，也就是说，假如上述字符串为 abcd123+456efg ，那就没法匹配成功，因为 456 和 123 不一样，而 \\1 代表的的是前面的 ([0-9]+) 所匹配到的 123 , 而不是它自身。 接着话题回到替换上。替换基本上也是和上面一样，但是把反斜杠 \\ 换成了 $ , 用于表示要保留的内容（大概）。举个例子，要把 className={styles.mapContainer} 替换成 className='mapContainer' ，查找和替换的正则表达式可以这么写： 12classname=\\{styles.([A-Za-z0-9]+)\\} // 查找className='$1' // 替换 其中的 $1 就代表 ([A-Za-z0-9]+) 所匹配到的内容: mapContainer ，也就是想要保留的部分。要是有多个捕获组，当然也可以用 $2、$3 这类。个人觉得吧，替换的部分可能压根就不能用正则表达式，顶多只能像这样复用一下查找时匹配到的内容吧？ 高软老师的补充： 昨天课后讨论有关捕获组的用法，在匹配时仅适用于重复的字串，比如 219219219 或者 ABC ABC，这样的才能用 \\1 替代捕获组小括号里的匹配结果，在（）+ 这样将捕获组作为一个元素出现 1 次或多次的情况，\\1 代表最后一次匹配结果。 本文其实也用了这种方法替换中英文的逗号：匹配 ([\\u4e00-\\u9fa5]),([\\u4e00-\\u9fa5]) 替换为 $1，$2效果：汉字之间的英文逗号替换为中文逗号","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E5%9B%9B/"},{"title":"好客租房项目的小笔记 (二)","text":"本文主要介绍了 js 中 map() 和forEach()的区别以及为什么 react 要用map()。 关于 React 里面为什么渲染重复组件时用 map() 不用 forEach()首先，arr.map(callback()) 和 arr.forEach(callback()) 都可以遍历数组，二者区别在于，map() 会返回一个新的数组，而 forEach() 则不会。 先看一下项目里的用法吧： 12345678910111213141516171819202122232425renderTabItem() { return tabItems.map((item) =&gt; { return ( &lt;TabBar.Item //... &gt; &lt;/TabBar.Item&gt; ) })}//...render() { return ( &lt;div className=&quot;home&quot;&gt; //... &lt;TabBar&gt; { this.renderTabItem() } &lt;/TabBar&gt; &lt;/div&gt; )}} 以下是个人理解：既然是要渲染 dom 元素，那最后必然要有返回值才行。这里 map() 的回调函数中的 return ，实际上是返回了一个新数组中的一个个元素。也就是说，最后会得到一个元素为 JSX 节点的新数组，然后再经由最外侧的 return 返回给 render() 用于渲染组件（ JSX 会自己把数组中的元素一个个渲染出来）。 如果用 forEach() 的话，没有返回值，所以不行。","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%BA%8C/"},{"title":"ES5 中的构造函数与 ES6 中 Class 的关系","text":"众所周知，ES6 中新增的 Class 就是此前的构造函数的语法糖，虽然现在都用 class 很方便，但是面试肯定是会问到构造函数的用法的，因此还是得搞明白。 二者的使用当然是有区别的啦。 构造函数 构造函数和普通函数的区别在于，一般来说，构造函数命名时都是首字母大写的。但这个说到底也只是建议，大小写本身并不会影响函数的性质。任何一个函数，如果使用了new，那它就能实现构造函数的效果，同理，只要不new，首字母大写的函数也能和普通函数一样执行。 1234567function Fn(){ this.name='Fn' console.log(this.name)}Fn()// 控制台输出: Fn 12345678function fn(){ this.name='fn'}var fobj=new fn()console.log(fobj)// 控制台输出: fn {name: &quot;fn&quot;}// 也就是定义了一个 fn 类型的对象 构造函数中，通过 this.xxx 定义成员变量，也就是实例变量，最后会赋值给每一个实例对象。但是测试了一下，构造函数中似乎不能用 static 定义静态变量。静态变量应在函数外部用 FunctionName.xxx=xxx 来定义。 定义成员方法的话，可以直接在函数内部像普通成员变量一样定义，即 this.fn=function(){} 的形式，这样会给每一个实例对象都复制一份这个方法，可能有点浪费空间，因此一般建议放在原型对象上，即 1FunctionName.prototype.xxx=function(){} 这样函数本身就只会有一份，每个实例对象调用该方法时只需查找 原型链 就能找到该方法。 Class Class 的思路其实和上面的一样，只是优化了写法而已。 12345678910111213141516171819202122class Person { constructor(name) { this.name = name; } age=12 // 方式一 say() { console.log('this is say', this); } // 方式二 say2 = function (params) { console.log('this is say2', this); } // 方式三 say3 = () =&gt; { console.log('this is say3', this); }} 上面的代码是从 JS 的 class 中成员方法定义的小细节 中复制过来的，并添加了第 6 行。 可以看到，Class 中多了一个constructor()，学过其他面向对象语言应该很熟悉，这个也叫构造函数。用途其实和之前的构造函数差不多，就是用来初始化成员变量的。 然后是第 6 行的 age=12，class 中，定义成员变量其实也可以不用构造函数，直接写在 class 内，这样也可以省略this 关键词。但是只有 constructor() 的参数能够从外部传入，因此这种写法只能用于初始化不需要从外部获取数据以初始化的成员变量。 成员方法的定义具体可以看JS 的 class 中成员方法定义的小细节，这里就不多赘述了。 new 在执行时会做四件事情： ① 在内存中创建一个新的空对象。 ② 让 this 指向这个新的对象。 ③ 执行构造函数里面的代码，给这个新对象添加属性和方法。 ④ 返回这个新对象（所以构造函数里面不需要 return ）。 顺便，构造函数理论上是用来初始化对象的，也不能 return，因此最好不要在里面写一些过于复杂的逻辑。 但是个人感觉，有的时候也不能太死板。比如要初始化成员变量为数组，且数组内容是 1~999 的数字，总不能呆呆地写个 this.arr=[1,2,3...] 吧？写个循环来初始化也是在所难免的。也不用担心会执行出错，毕竟执行构造函数时和执行普通函数并没有什么区别，无非是自动调用了而已。","link":"/2021/11/28/ES5%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8EES6%E4%B8%ADClass%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"React 脚手架中怎么安装 sass(其他包同理)","text":"总之，脚手架里面的 npm 要用局部安装。 最近用 react 脚手架（create-react-app）新创建了一个 react 项目，但是不能使用 .scss 文件，提示 1Cannot find module 'sass' 我试着执行了： 123$ npm i -g sass$ npm i -g sass-loader$ npm i node-sass // 这一条不知道为什么卡住了，没执行成功 但是一点用都没有。后来又看了看之前做好客租房的那个教程，又去看了看create-react-app 官方文档，再结合 stackoverflow 上的回答，好像是搞清楚为啥了。 首先，官方文档推荐的是执行 123$ npm install node-sass --save$ # or$ yarn add node-sass 但毕竟是 19 年的文档，有点过时了。现在 node-sass 好像停止维护了？现在要执行的是： 1$ npm i sass 注意，千万不要加-g，我之所以不能成功就是因为使用了全局安装。全局安装是把包下到 node 的安装目录里，可以让命令行使用，但是不会添加到当前项目的目录下，更不会修改当前项目的配置文件，所以还是没法用。 顺便贴一篇文章，详细介绍了局部安装和全局安装的区别：npm 全局安装和局部安装的区别","link":"/2021/12/04/React%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85sass(%E5%85%B6%E4%BB%96%E5%8C%85%E5%90%8C%E7%90%86)/"},{"title":"利用 OpenSSL 实现 HTTPS","text":"信息安全实践课 实验一 搭建 https 服务 前言 所有的命令行操作，需要确保是用户而不是 root 模式； 其次，遇到 permission denied 就说明需要权限，在对应命令前面加上 sudo 即可； 再其次，很多时候出错了会有提示，仔细看看说不定能知道为什么出错。 正文 首先写贴一下给的教程吧，也就是 Ubuntu 的社区教程：OpenSSL。以及老师（其实应该是学长）给的 PDF 的教程部分： 以上就是全部的资料了。 下面基于文档（的机翻）以及我自己的经验简单写一下流程。 首先当然是要安装 ubuntu 和 OpenSSL 啦，网上搜一下教程一堆。我是直接装的最新版的 ubuntu 20.04，OpenSSL 版本应该是和系统配套的，所以应该也蛮新的。这也导致后面出了好多问题。 在用户目录（比如我就是 /home/iyiak/ ）新建 myCA 文件夹以及内部的两个子文件夹。 1cd &amp;&amp; mkdir -p myCA/signedcerts &amp;&amp; mkdir myCA/private &amp;&amp; cd myCA 在 myCA 目录下创建初始证书数据库 1echo '01' &gt; serial &amp;&amp; touch index.txt 在 myCA 目录里创建caconfig.cnf，这个其实就是后面创建 CA 时的配置文件，可以用命令 1sudo nano ~/myCA/caconfig.cnf 打开 vim 来编辑，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# My sample caconfig.cnf file.## Default configuration to use when one is not provided on the command line.#[ca]default_ca = local_ca### Default location of directories and files needed to generate certificates.#[local_ca]dir = /home/iyiak/myCAcertificate = $dir/cacert.pemdatabase = $dir/index.txtnew_certs_dir = $dir/signedcertsprivate_key = $dir/private/cakey.pemserial = $dir/serial# ## Default expiration and encryption policies for certificates.#default_crl_days = 365default_days = 1825default_md = sha256# policy = local_ca_policyx509_extensions = local_ca_extensions### Copy extensions specified in the certificate request#copy_extensions = copy# ## Default policy to use when generating server certificates. The following# fields must be defined in the server certificate.#[local_ca_policy]commonName = suppliedstateOrProvinceName = suppliedcountryName = suppliedemailAddress = suppliedorganizationName = suppliedorganizationalUnitName = supplied# ## x509 extensions to use when generating server certificates.#[local_ca_extensions]basicConstraints = CA:false# ## The default root certificate generation policy.#[req]default_bits = 2048default_keyfile = /home/iyiak/myCA/private/cakey.pemdefault_md = sha256# prompt = nodistinguished_name = root_ca_distinguished_namex509_extensions = root_ca_extensions### Root Certificate Authority distinguished name. Change these fields to match# your local environment!#[root_ca_distinguished_name]commonName = MyOwn Root Certificate AuthoritystateOrProvinceName = jiangsucountryName = CNemailAddress = abc@abc.comorganizationName = ABC organizationalUnitName = IT Department# [root_ca_extensions]basicConstraints = CA:true 这个是按照文档修改来的，其中 11 行和 57 将文档中的路径改成了自己的 /home/iyiak/myCA/...；24 行和 58 行将加密算法由原来的sha1 改为了sha256，不改的话后面没办法启动 apache2，错误信息大概意思就是不够安全，在室友的电脑上尝试了 Ubuntu 18.04，就不需要修改这个，所以应该是新版的要求更严格了。 然后就是修改了 68 行开始的 [root_ca_distinguished_name]，内容随意吧，差不多就行了，好像countryName 必须是两个字母。 下面的命令设置了一个环境变量 OPENSSL_CONF，它强制openssl 工具在替代位置（在本例中为~/myCA/caconfig.cnf）查找配置文件。 1export OPENSSL_CONF=~/myCA/caconfig.cnf 使用以下命令生成 CA 证书和密钥，CA 证书的参数就是上面的 caconfig.cnf 设置的。 1openssl req -x509 -newkey rsa:2048 -out cacert.pem -outform PEM -days 1825 这一步应该会提示输入密码： 1234567Generating a RSA private key.................................+++.................................................................................................+++writing new private key to '/home/bshumate/myCA/private/cakey.pem'Enter PEM pass phrase:Verifying - Enter PEM pass phrase:----- 一定要记住这里设置的密码，每次要生成和签署新的服务器或客户端证书时都需要它。 上述过程将使用 PEM 格式和 RSA 公钥 / 私钥加密创建自签名证书。该证书的有效期为 1825 天。生成的文件的位置和用途如下： ~/myCA/cacert.pem : CA 公共证书 ~/myCA/private/cakey.pem : CA 私钥 至此为止 CA 部分就完成了。接下来就是要生成签发给服务器的证书。 编辑 ~/myCA/exampleserver.cnf 文件，这里面的内容一定要和网站（本例就是 localhost）一样。 12345678910111213141516171819202122232425## exampleserver.cnf#[req]prompt = nodistinguished_name = server_distinguished_namereq_extensions = v3_req[server_distinguished_name]commonName = localhoststateOrProvinceName = jiangsucountryName = CNemailAddress = cky@abc.comorganizationName = My OrganizationorganizationalUnitName = Subunit of My Large Organization[v3_req]basicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName = @alt_names[alt_names]DNS.0 = localhostDNS.1 = 127.0.0.1 这里关键就是 11 行的 commonName 和 24、25 行的 DNS，我试了好多遍，反正最后按上面的设置是成功了。但至于为什么能成功我也不知道，明明之前也试过 localhost 但是不能成，唉。 接下来当然是要使用上面的配置文件了： 1export OPENSSL_CONF=~/myCA/exampleserver.cnf 生成证书和密钥： 1openssl req -newkey rsa:2048 -keyout tempkey.pem -keyform PEM -out tempreq.pem -outform PEM 注意，这里是 rsa:2048 而教程是rsa:1024，最新的 SSL 要求密钥必须是 2048 位的，否则 apache2 没法启动。 还会让设置密码，设好了记住就行了。 接下来，使用以下命令将临时私钥转换为未加密的密钥： 1openssl rsa &lt; tempkey.pem &gt; server_key.pem 这里会要验证密码，不是设置密码了。 12Enter pass phrase:writing RSA key 现在，您需要使用以下命令使用证书颁发机构 (CA) 密钥签署服务器证书： 1export OPENSSL_CONF=~/myCA/caconfig.cnf 然后按如下方式签署证书： 1openssl ca -in tempreq.pem -out server_crt.pem 会需要输入密码，展示一些在 exampleserver.cnf 里设置的信息，还需要两次确定（y）： 123456789101112131415161718Using configuration from /home/iyiak/myCA/caconfig.cnfEnter pass phrase for /home/iyiak/myCA/private/cakey.pem:Check that the request matches the signatureSignature okThe Subject's Distinguished Name is as followscommonName :ASN.1 12:'localhost'stateOrProvinceName :ASN.1 12:'jiangsu'countryName :PRINTABLE:'CN'emailAddress :IA5STRING:'cky@abc.com'organizationName :ASN.1 12:'My Organization'organizationalUnitName:ASN.1 12:'Subunit of My Large Organization'Certificate is to be certified until Dec 8 12:42:42 2026 GMT (1825 days)Sign the certificate? [y/n]:y1 out of 1 certificate requests certified, commit? [y/n]yWrite out database with 1 new entriesData Base Updated 然后就可以删掉一些临时文件，当然这一步跳过也没问题 1rm -f tempkey.pem &amp;&amp; rm -f tempreq.pem 至此，您现在拥有自签名服务器应用程序证书和密钥对，可以在 myCA 目录里直接看到这两个文件： server_crt.pem : 服务器应用程序证书文件 server_key.pem : 服务器应用程序密钥文件 最后还需要生成用于导入浏览器的包含证书和密钥文件（这里也把 rsa:1024 改成了 rsa:2048，虽然不改这里也不会报错，但是改了反正没坏处）： 1openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout mycert.pem -out mycert.pem 然后，使用以下命令将此证书 / 密钥组合文件转换为 PKCS#12 证书： 1openssl pkcs12 -export -out mycert.pfx -in mycert.pem -name &quot;Certificate for Whatever&quot; 命令行中的操作就以上这么多。最后再将上面生成的文件导入浏览器就行。 我尝试过，箭头的两个地方都能导入，第一个’您的证书’里可以导入最后生成的 .pfx 文件，但是’证书颁发机构’就只能导入 .pem 文件，这里就导入了 mycert.pem 和cacert.pem。具体哪个才是有用的我也不知道，反正我都导入了。 剩下还需要配置一下服务器，这部分是参考了老师给的 pdf： 首先就是要安装 apache 了，我依然是装的最新版 Apache/2.4.41。由于我用的是 WSL2，用不了 systemctl 之类的命令，所以我用的几个 apache 相关的命令是： 1234sudo service apache2 startsudo service apache2 restartsudo service apache2 stopsudo service apache2 status 建⽴ssl 配置⽂件 lab-ssl.conf 1sudo nano /etc/apache2/sites-available/lab-ssl.conf 内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;IfModule mod_ssl.c&gt; &lt;VirtualHost _default_:443&gt; ServerAdmin webmaster@localhost DocumentRoot /var/www/lab # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with &quot;a2disconf&quot;. #Include conf-available/serve-cgi-bin.conf # SSL Engine Switch: # Enable/Disable SSL for this virtual host. SSLEngine on # A self-signed (snakeoil) certificate can be created by installing # the ssl-cert package. See # /usr/share/doc/apache2/README.Debian.gz for more info. # If both key and certificate are stored in the same file, only the # SSLCertificateFile directive is needed. #SSLCertificateFile /etc/ssl/certs/ssl-cert-snakeoil.pem #SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key # 网站证书和私钥地址 SSLCertificateFile /home/&lt;username&gt;/myCA/server_crt.pem SSLCertificateKeyFile /home/&lt;username&gt;/myCA/server_key.pem # Server Certificate Chain: # Point SSLCertificateChainFile at a file containing the # concatenation of PEM encoded CA certificates which form the # certificate chain for the server certificate. Alternatively # the referenced file can be the same as SSLCertificateFile # when the CA certificates are directly appended to the server # certificate for convinience. #SSLCertificateChainFile /etc/apache2/ssl.crt/server-ca.crt # Certificate Authority (CA): # Set the CA certificate verification path where to find CA # certificates for client authentication or alternatively one # huge file containing all of them (file must be PEM encoded) # Note: Inside SSLCACertificatePath you need hash symlinks # to point to the certificate files. Use the provided # Makefile to update the hash symlinks after changes. #SSLCACertificatePath /etc/ssl/certs/ #SSLCACertificateFile /etc/apache2/ssl.crt/ca-bundle.crt # Certificate Revocation Lists (CRL): # Set the CA revocation path where to find CA CRLs for client # authentication or alternatively one huge file containing all # of them (file must be PEM encoded) # Note: Inside SSLCARevocationPath you need hash symlinks # to point to the certificate files. Use the provided # Makefile to update the hash symlinks after changes. #SSLCARevocationPath /etc/apache2/ssl.crl/ #SSLCARevocationFile /etc/apache2/ssl.crl/ca-bundle.crl # Client Authentication (Type): # Client certificate verification type and depth. Types are # none, optional, require and optional_no_ca. Depth is a # number which specifies how deeply to verify the certificate # issuer chain before deciding the certificate is not valid. #SSLVerifyClient require #SSLVerifyDepth 10 # SSL Engine Options: # Set various options for the SSL engine. # o FakeBasicAuth: # Translate the client X.509 into a Basic Authorisation. This means that # the standard Auth/DBMAuth methods can be used for access control. The # user name is the `one line' version of the client's X.509 certificate. # Note that no password is obtained from the user. Every entry in the user # file needs this password: `xxj31ZMTZzkVA'. # o ExportCertData: # This exports two additional environment variables: SSL_CLIENT_CERT and # SSL_SERVER_CERT. These contain the PEM-encoded certificates of the # server (always existing) and the client (only existing when client # authentication is used). This can be used to import the certificates # into CGI scripts. # o StdEnvVars: # This exports the standard SSL/TLS related `SSL_*' environment variables. # Per default this exportation is switched off for performance reasons, # because the extraction step is an expensive operation and is usually # useless for serving static content. So one usually enables the # exportation for CGI and SSI requests only. # o OptRenegotiate: # This enables optimized SSL connection renegotiation handling when SSL # directives are used in per-directory context. #SSLOptions +FakeBasicAuth +ExportCertData +StrictRequire &lt;FilesMatch &quot;\\.(cgi|shtml|phtml|php)$&quot;&gt; SSLOptions +StdEnvVars &lt;/FilesMatch&gt; &lt;Directory /usr/lib/cgi-bin&gt; SSLOptions +StdEnvVars &lt;/Directory&gt; # SSL Protocol Adjustments: # The safe and default but still SSL/TLS standard compliant shutdown # approach is that mod_ssl sends the close notify alert but doesn't wait for # the close notify alert from client. When you need a different shutdown # approach you can use one of the following variables: # o ssl-unclean-shutdown: # This forces an unclean shutdown when the connection is closed, i.e. no # SSL close notify alert is send or allowed to received. This violates # the SSL/TLS standard but is needed for some brain-dead browsers. Use # this when you receive I/O errors because of the standard approach where # mod_ssl sends the close notify alert. # o ssl-accurate-shutdown: # This forces an accurate shutdown when the connection is closed, i.e. a # SSL close notify alert is send and mod_ssl waits for the close notify # alert of the client. This is 100% SSL/TLS standard compliant, but in # practice often causes hanging connections with brain-dead browsers. Use # this only for browsers where you know that their SSL implementation # works correctly. # Notice: Most problems of broken clients are also related to the HTTP # keep-alive facility, so you usually additionally want to disable # keep-alive for those clients, too. Use variable &quot;nokeepalive&quot; for this. # Similarly, one has to force some clients to use HTTP/1.0 to workaround # their broken HTTP/1.1 implementation. Use variables &quot;downgrade-1.0&quot; and # &quot;force-response-1.0&quot; for this. # BrowserMatch &quot;MSIE [2-6]&quot; \\ # nokeepalive ssl-unclean-shutdown \\ # downgrade-1.0 force-response-1.0 &lt;/VirtualHost&gt;&lt;/IfModule&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet 还是把老师给的文件粘贴了一下，要注意源文件第 5 行的注释格式有问题，所以我直接删掉了。36、37 行的文件路径还要修改为自己的才行。 此外，第 5 行是将默认的 https 打开的页面指向 /var/www/lab，但是初始状态下/var/www 文件夹里只有 /html 这一个文件夹，里面只包含一个 html 文件。因此，这里要手动在 /var/www 下创建 lab 文件夹，并在其中创建一个简单的 html 文件用于显示 hello world。 启动 ssl 服务，命令： 1a2ensite 如果提示没有权限就在前面加个 sudo，然后会需要选择啥东西来着，可能是配置文件吧，会有三个选项，总之输入lab-ssl 回车。 1a2enmod ssl 执行之后重启 apache 即可。如果重启失败，可以去 /var/log/apache2/error.log 看看错误日志，然后再去 google 一下。 最后就是在新标签页的地址栏输入https://localhost/，地址栏最左边出现小锁就说明大功告成啦。 Q&amp;A：Q：万一中途操作失误咋办？ A：直接删除 myCA 文件夹，再从头开始，简单粗暴。 Q：似乎没有办法重新生成一个 common name 一样的证书？如果有这需求（比如修改 dns）该怎么删除原先的证书？ A：最重要的是要删除数据库中的记录，所谓数据库，其实也就是 myCA 里的index.txt，删除对应的行即可。保险起见最好把之前生成的证书一并删掉。 Q：为什么我按照教程一步步来还是不行？ A：我也想知道。我甚至想知道为什么我突然就成了。","link":"/2021/12/09/%E5%88%A9%E7%94%A8OpenSSL%E5%AE%9E%E7%8E%B0HTTPS/"},{"title":"Redux, React Redux, Redux Toolkit 的简单使用","text":"本文简单介绍了 Redux 和 React Redux 的使用，同时在此基础上，结合官方教程对 Redux Toolkit 进行了简单的理解。 redux 的基本用法 这部分就简单介绍一下每个部分对应哪些文件，以及每个文件的作用吧。 上面是简单使用 redux 时的文件目录。 count_reducer.js就对应的原理图中的 reducers，用于实现对状态的初始化以及后续的处理： 1234567891011121314151617181920/* 1. 该文件是用于创建一个为 Count 组件服务的 reducer，reducer 本质就是一个函数 2. 该函数会接到两个参数，分别为：之前的状态：preState, 动作对象：action*/import { INCREMENT, DECREMENT } from &quot;./constant&quot;;const INIT = 0export default function countReducer(preState = INIT, action) { const { type, data } = action switch (type) { case INCREMENT: return preState + data case DECREMENT: return preState - data default: return preState }} count_action.js对应 Action Creators，仅用于返回对应的 action： 1234567/* 该文件专门为 Count 生成 action 对象*/import { INCREMENT, DECREMENT } from &quot;./constant&quot;;export const createIncrementAction = data =&gt; ({ type: INCREMENT, data }) // 箭头函数只有一句返回语句可以去掉 return 和花括号，但是对象的花括号会和函数体的花括号混淆，所以需要外面套个小括号export const createDecrementAction = data =&gt; ({ type: DECREMENT, data }) constant.js仅用于定义字符串常量： 123456/* 该文件用于定义 action 对象中 type 类型的常量值, 防止单词拼错*/export const INCREMENT = 'increment'export const DECREMENT = 'decrement' store.js为 redux 的核心部分，所有状态都由 store 管理： 1234import { createStore } from 'redux'import countReducer from './count_reducer'export default createStore(countReducer) 为了监听 store 中状态的变化以及时更新组件，还需要在 index.js 中添加订阅： 123456789101112import React from 'react'import ReactDom from 'react-dom'import APP from './APP'import store from './redux/store'ReactDom.render(&lt;APP /&gt;, document.querySelector(&quot;#root&quot;))// 当 store 更新时重新渲染组件store.subscribe(() =&gt; { ReactDom.render(&lt;APP /&gt;, document.querySelector(&quot;#root&quot;))}) 接下来就可以在组件中使用 redux 了，可以直接在组件中引入 store 并使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, { Component } from 'react'// 引入 storeimport store from '../../redux/store'import { createIncrementAction, createDecrementAction } from '../../redux/count_action'export default class Count extends Component { increment = () =&gt; { let num = this.selectNum.value // 将 action 对象发给 store store.dispatch(createIncrementAction(num * 1)) } decrement = () =&gt; { let num = this.selectNum.value store.dispatch(createDecrementAction(num * 1)) } incrementIfOdd = () =&gt; { let num = this.selectNum.value if (store.getState() % 2 === 1) store.dispatch(createIncrementAction(num * 1)) } incrementAsync = () =&gt; { let num = this.selectNum.value setTimeout(() =&gt; { store.dispatch(createIncrementAction(num * 1)) }, 1000); } render() { return ( &lt;div&gt; &lt;h1&gt;当前结果：{store.getState()}&lt;/h1&gt; &lt;select ref={c =&gt; this.selectNum = c}&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &amp;nbsp; &lt;button onClick={this.increment}&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.incrementIfOdd}&gt;奇数时 +&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.incrementAsync}&gt;异步 +&lt;/button&gt; &lt;/div&gt; ) }} 也可以在 APP.js 中引入 store，再作为 props 传给所有的子组件，这里就不演示了。 此外，虽然这里没有用到，但是如果需要异步发送 action，需要引入中间件thunk，这里直接贴几张视频截图来展示怎么操作吧。 首先是安装需要的插件： 1npm i redux-thunk 接着修改store.js： 然后异步 action 要这么写： 这里返回值函数的形参是 dispatch，就很奇怪啊，按理说是store.dispatch(createIncrementAsyncAction(num * 1)) 这么调用的，也就是返回值函数最后是作为 store.dispatch() 的参数。那也就是说，store.dispatch()内部调用返回值函数时，还能传一个 dispatch 进去？套娃？ react-redux 的基本用法 个人感觉，react-redux 比单纯的用 redux 还要麻烦…… 首先是最后的目录结构，这里为了模拟有多个状态需要管理的情况，使用了 count 和 person 两个状态。 原先的 redux 部分其实还是差不多，只是由于有了多个 reducer 和 action，所以修改了目录结构以及文件名，比如 count_action.js 和count_reducer.js都重命名为count.js，且移动到了相应的文件夹下。 由于有了多个 reducer，因此 store 中不可能一个个分别传入 createStore()，需要在 reducers 文件夹中新建index.js 文件用于汇总所有 reducer： 123456789101112/* 该文件用于汇总所有的 reducer 为一个总的 reducer */import { combineReducers } from 'redux'import count from './count'import person from './person'// 汇总所有的 reducer 变为一个总的 reducer// 这里返回的键值对中的 key，对应容器中的 state.xxx 虽然值这里写的是 reducer，但实际上是 reducer 的返回值export default combineReducers({ count, // 这里是 count:count 的简写 person}) 接着修改store,js： 12345678910// 引入 createStore，用于创建 redux 中最核心的 store 对象import { createStore } from 'redux'// 引入汇总后的 reducerimport allReducers from './reducers'import { composeWithDevTools } from 'redux-devtools-extension'// 如果需要异步操作还需要引入 thunk，但我把异步操作放在了组件里，就没必要了export default createStore(allReducers, composeWithDevTools())// 合并 reducer 后，在 count 里也可以发送 person 的请求 createStore()的第二个参数用于使用 Redux Devtools 这个浏览器插件。如果此时还需要异步编程，要这么写： 1export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk))) 接下来就是要修改组件了。 react-redux 要求组件分为 UI 组件和容器组件，UI 组件中不能包含逻辑代码（应该是指不能直接使用 store 吧），然后通过容器组件包裹 UI 组件，将对 redux 的操作作为 props 传递进去。一般来说容器组件和 UI 组件应该分成两个文件，但是简写之后可以直接放在一个文件里。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import { connect } from 'react-redux'import { increment, decrement } from &quot;../../redux/actions/count&quot;;import React, { Component } from 'react'class Count extends Component { increment = () =&gt; { let num = this.selectNum.value this.props.increment(num * 1) } decrement = () =&gt; { let num = this.selectNum.value this.props.decrement(num * 1) } incrementIfOdd = () =&gt; { let num = this.selectNum.value if (this.props.count % 2 === 1) this.props.increment(num * 1) } incrementAsync = () =&gt; { let num = this.selectNum.value setTimeout(() =&gt; { // 异步操作理论上不该这么写，但是这里就偷个懒吧 this.props.increment(num * 1) }, 1000); } render() { // console.log(this.props); return ( &lt;div&gt; {/* {console.log(this.props)} */} &lt;h1&gt; 计数组件，当前人数：{this.props.personNum}&lt;/h1&gt; &lt;h2&gt;当前结果：{this.props.count}&lt;/h2&gt; &lt;select ref={c =&gt; this.selectNum = c}&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &amp;nbsp; &lt;button onClick={this.increment}&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.incrementIfOdd}&gt;奇数时 +&lt;/button&gt;&amp;nbsp; &lt;button onClick={this.incrementAsync}&gt;异步 +&lt;/button&gt; &lt;/div&gt; ) }}// 优化后的 connect，第一个括号中的第二个参数可以直接传对象，值直接为 action creator// 相当于直接把 createIncrementAction 复制给了 increment,UI 组件调用 increment 直接传入参数即可，dispatch 返回的 action 由 API 实现export default connect( state =&gt; ({ count: state.count, personNum: state.person.length }), { increment, decrement })(Count)//container 是 UI 组件的父组件 考虑到容器组件简写过头了不太好理解，这里也粘贴一份未简写的容器组件，看函数名应该很好理解： 12345678910111213141516171819import Counter from '../components/Counter'import {createIncrementAction,createDecrementAction} from '../redux/action_creators'import {connect} from 'react-redux'let mapStateToProps=(state)=&gt;{ return {count:state}}let mapDiaptachToProps=(disptach)=&gt;{ return { increment:(value)=&gt;{dispatch(createIncrementAction(value))}, decrement:(value)=&gt;{dispatch(createDecrementAction(value))} }}export default connect( mapStateToProps, mapDispatchToProps)(Counter) connect()()用于连接 store 和 UI 组件，connect()()内部调用 mapStateToProps 和mapDispatchToProps时，一定能够将对应的 state 和dispatch传进去。 最后，使用 react-redux 后就不需要手动监听 store 是否变化了，只需修改 index.js 为： 123456789101112131415161718// import React from 'react'import ReactDom from 'react-dom'import APP from './APP'// import store from './redux/store'import store from './redux/store'import { Provider } from &quot;react-redux&quot;;ReactDom.render( /* 此处需要用 Provider 包裹 App, 目的是让 App 所有的后代组件都能接收到 store */ &lt;Provider store={store}&gt; &lt;APP /&gt; &lt;/Provider&gt;, document.querySelector(&quot;#root&quot;))// store.subscribe(() =&gt; {// ReactDom.render(&lt;APP /&gt;, document.querySelector(&quot;#root&quot;))// }) React-Redux 的基本上就这样了。当然这里没有用到 hooks，可能是我看的教程太老了。但是没有问题，反正我打算直接用下面的 Redux Toolkit 了。 Redux Toolkit 的基本使用 可能官方也觉得 redux 太繁琐了，所以推出了 Redux Toolkit，旨在简化 redux 的操作。现在 react-redux 的 官方教程 都是直接用的 Redux Toolkit。 我看官方教程写的挺通俗易懂的，所以这里就不自己写了。 但是还是要写几条自己对 官方示例 中代码的理解： counterSlice.js这个文件中，很明显，createSlice()起码实现了 action creators 和 reducers 的功能。然后需要从该函数创建出来的 slice 对象中提取出 actions 和 reducer，并将 reducer 默认暴露出去。 31 行的 12345export const incrementAsync = amount =&gt; dispatch =&gt; { setTimeout(() =&gt; { dispatch(incrementByAmount(amount)); }, 1000);}; 展示了异步 action 要怎么实现：和原来的实现一模一样，只是写成了箭头函数的形式，还原一下就是： 123456export const incrementAsync = (amount) =&gt; { return (dispatch)=&gt; { setTimeout(() =&gt; { dispatch(incrementByAmount(amount)); }, 1000);}}; 40 行的 1export const selectCount = state =&gt; state.counter.value; 单看不太好理解，其实是把教程中的示例代码中的 1const count = useSelector((state) =&gt; state.counter.value) 分成了 Counter.js 中的 123import {selectCount} from './counterSlice';//...const count = useSelector(selectCount); // 第 13 行 和 counterSlice.js 中的 1export const selectCount = state =&gt; state.counter.value; 两部分。 个人理解，意思是，useSelector()中调用作为参数的函数 (state) =&gt; state.counter.value，然后会将 store 的整个 state 传入这个函数里，而 state 又是一个大整体，必须指明 count 是 state 中的哪一部分才行，这里就是state.counter.value（value 是在createSlice() 中定义初值时自己起的名字），然后 useSelector() 就将指明的值赋给 count。 当然啦，useSelector()是一个 hook，所以具体实现起来肯定不会这么简单，但是我觉得这么理解应该不会有啥问题。 最后还要写一下 createSlice() 这个函数里，reducers 的定义方法。示例里面是这么写的 123456789101112131415reducers: { increment: state =&gt; { // Redux Toolkit allows us to write &quot;mutating&quot; logic in reducers. It // doesn't actually mutate the state because it uses the immer library, // which detects changes to a &quot;draft state&quot; and produces a brand new // immutable state based off those changes state.value += 1; }, decrement: state =&gt; { state.value -= 1; }, incrementByAmount: (state, action) =&gt; { state.value += action.payload; }, } key 理论上就是 action 的 type，似乎 type 和创建 action 的函数名是一样的；每个值，即 reducer，对应一个处理函数。 这里需要注意的是处理函数的参数。默认是有一个 state，可以理解为原先的 prestate 吧，从这里没写成 state.counter.value+=1 来看，这时的 state 只是 counter 的 state。 然后如果需要传其他值给处理函数，需要传入第二个参数 action。incrementByAmount就是这么做的，我试着打印了 incrementByAmount 的 action，如图 可以看到，真正的值是作为 payload 存在里面的。所以是state.value += action.payload。 但这是只有一个值的情况，要是有多个值要处理怎么办？难道是传一个对象作为 payload？这个之后再研究吧。","link":"/2021/12/13/Redux-React-Redux-Redux-Toolkit-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"高阶函数的参数函数的参数问题","text":"学 redux 时的一个小疑问 高阶函数有函数参数，且这个作为参数的函数也有自己的参数，比如 12345678910111213141516171819import Counter from '../components/Counter'import {createIncrementAction,createDecrementAction} from '../redux/action_creators'import {connect} from 'react-redux'let mapStateToProps=(state)=&gt;{ return {count:state}}let mapDiaptachToProps=(disptach)=&gt;{ return { increment:(value)=&gt;{dispatch(createIncrementAction(value))}, decrement:(value)=&gt;{dispatch(createDecrementAction(value))} }}export default connect( mapStateToProps, mapDispatchToProps)(Counter) 这是 react-redux 中容器组件的完整写法，其中 connect()() 是一个高阶函数，它的第一个括号里的第一个参数，传递了一个函数作为参数。为了方便理解，我就没有进行简写，而是单独在外面定义了 mapStateToProps 和mapDiaptachToProps。 问题就是，mapStatetoProps的参数 state，是哪冒出来的？ 仔细想了想，想通了。 函数的括号里的参数，只是形参而已，形式参数是在调用时赋值的，而这里只是定义函数，形参叫 state 还是叫 peiqi 都没有区别。这个函数的效果只是将 调用时 传进来的 实参 放进对象并返回而已。 那么这个函数，作为参数传给了 connect()()，必然是要在 connect 内部调用的。redux 中的 state，是由 store 保管的，而connect()() 就是用来连接 store 和 UI 组件的，它的内部肯定能获得 store 中的 state，继而作为实参传给mapStatetoProps。 同理，也能够说明 mapDispatchToProps 为什么要这么写。dispatch作为形式参数，需要由 connect 内部调用 mapDispatchToProps 时传递一个实参才行，而很明显，到时候传进去的实参就是 store 的 dispatch() 函数。","link":"/2021/12/13/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"信息安全","slug":"信息安全","link":"/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"课程实验","slug":"课程实验","link":"/tags/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"},{"name":"OpenSSL","slug":"OpenSSL","link":"/tags/OpenSSL/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"React-Redux","slug":"React-Redux","link":"/tags/React-Redux/"}],"categories":[{"name":"note","slug":"note","link":"/categories/note/"},{"name":"学习","slug":"note/学习","link":"/categories/note/%E5%AD%A6%E4%B9%A0/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"学习","slug":"Note/学习","link":"/categories/Note/%E5%AD%A6%E4%B9%A0/"}]}