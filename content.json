{"pages":[],"posts":[{"title":"JS 的 class 中成员方法定义的小细节","text":"本文主要介绍了在 ES6 中新增的 class 中定义成员方法的三种方式, 以及各自的 this 指向问题。 在类里面定义成员方法有三种方式，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang='zh'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;meta http-equiv='X-UA-Compatible' content='IE=edge'&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; class Person { constructor(name) { this.name = name; } // 方式一 say() { console.log('this is say', this); } // 方式二 say2 = function (params) { console.log('this is say2', this); } // 方式三 say3 = () =&gt; { console.log('this is say3', this); } } console.dir(Person); var chen = new Person('chen'); console.log(chen); chen.say() chen.say2() chen.say3() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;chen.say&lt;/button&gt; &lt;button&gt;chen.say2&lt;/button&gt; &lt;button&gt;chen.say3&lt;/button&gt; &lt;script&gt; var bt = document.querySelectorAll('button'); bt[0].addEventListener('click', chen.say); bt[1].addEventListener('click', chen.say2); bt[2].addEventListener('click', chen.say3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 依次点击三个按钮后，控制台截图如下： 方法名后直接跟括号以及大括号，即上述的 say(){}。 这种方式定义的方法会放在类的原型对象 (Person.prototype ) 上，用类定义实例对象时并不会放到实例对象中。实例对象调用该方法时会通过原型链（ chen.__proto__ ）查找到类的原型对象上，从而找到该方法。方法中的 this 会指向调用该方法的对象。比如上例中的 chen.say() 是由实例对象 chen 调用，因此 this 指向 chen 。而当该方法最为按钮的点击事件被调用时， this 则会指向触发事件的按钮 bt。 say2 = function(){}。这种方式，我也不知道它把方法存在哪去了，反正打印 Person 类是找不到的，但是反正最后会直接放在实例对象中。这种方式定义的方法的 this 指向和上一种相同，就不多说了。 箭头函数方式，say3=()=&gt;{}。这种方式在 React 的类式组件中最常用了。方法体也是直接放在实例对象中。最大的特点是用了箭头函数，因此 this 指向的是定义方法的上下文的 this ，就结果而言，其实也就是类的实例对象。不管是谁调用，就算用 call() 和 bind()， this 指向都不会变。","link":"/2021/11/15/JS%E7%9A%84class%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"},{"title":"JS 原型链","text":"本文主要介绍了 JS 中的原型链以及一些个人对原型链的理解。 首先 pink 老师给的原型链如上图，有些小细节需要注意: prototype称为显示原型 __proto__ 称为隐式原型，ES6 之前不能直接操作隐式原型 Object.prototype instanceof Object的返回值是 false，但 typeof(Object.prototype) 返回值则是 object, 这是因为 instanceof 原理是查找前面的参数的原型链看是否有后面的参数的prototype，但是Object.prototype 继续查 __proto__ 只能查到 null，所以返回 false 再有 null 和 undefined 的区别，阮一峰博客里的说法是: null 表示”没有对象”，即该处不应该有值。 undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 个人理解是 null 相当于占位符，即考虑到了这个，也定义了，但他就不该有值，因此是 null；但 undefined 往往是压根就没考虑过这个值，即“未定义”。 还有就是打印 Object.prototype 得到结果如下： 压根找不到 __proto__:null 这一项，个人理解是单纯没有显示出来，因为尝试打印了一个乱码结果如下： 可以看到返回值是 undefined 而不是 null 而打印 Object.prototype.__proto__ 结果则是 null： 最后，关于 Object.__proto__, Object 作为 js 中的构造函数，那么它必然是个函数对象，既然是函数对象，那么它的隐式原型__proto__ 自然就是指向Function.prototype。 同理，任意一个构造函数的隐式原型都是 Function 的prototype 此外，Function 的 prototype 和 __proto__ 是一样的 所以最后原型链图我补充了一下：","link":"/2021/11/18/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"git push&#x2F;clone 操作失败的解决方法","text":"本文主要介绍自己之前遇到的 git push 和git clone总是失败的解决办法。 问题描述 之前刚开始尝试使用 git 操作的时候，git push 操作总是失败，一会报错是请求超时，一会报错是拒绝访问，然后最近刚开始写博客时，用到了 git clone，结果还是一样的问题。 之前也百度了很多方法，主要就三种： 修改 host 文件 关闭代理 忽略代理 我的确有开着代理，clash 一直在后台运行着。但实测无论开不开代理，开规则模式或者全局模式，网页都能正常访问 github，但是 git 操作就是死活不成功。然后使用 git 命令忽略代理，还是没效果。host 懒得改了，所以没试。总之都不行。 我试了有十几次，离谱的发现，报错还是随机的。在不开代理的情况下连续尝试了好几次git push，有几次是显示请求超时，有几次是拒绝访问，然后竟然还有那么一两次是可以成功的。反正当时我就这么类似卡 BUG 一样 勉强搞定了。 然后搭博客要用到git clone，不出所料依然一样的问题。这次又搜了搜，意外的发现还可以给 git 操作设置代理，然后就神奇的解决了……意外的很轻松呢，当时我可是纠结了几小时都没搞定啊。 解决方法 很简单，就给 git 设置代理就行了，命令如下： git config --global http.proxy &quot;localhost:port&quot; 这里的 port 端口是代理的端口，代理软件是 clash 的话，就是首页显示的这个 port。 然后就没有然后了。 当然，如果哪天不需要代理了，也可以用下面的命令关闭代理： git config --global --unset http.proxy ​ 其实到最后我也没搞清楚问题原因，个人猜测可能是 git push/clone 这两个操作请求的服务器被墙了吧，我这里宽带是联通的。至于为什么 github 网页能正常访问，emm，谁知道呢。 附上找到这个方法的文章链接： https://www.jianshu.com/p/471aeba64724","link":"/2021/11/18/git-push-clone%E6%93%8D%E4%BD%9C%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"React 中 Hook 的简单使用","text":"本文简单介绍了 React 16.8 中新增的 State Hook 和 Effect Hook 的使用。 前言 以往用 React 做项目时，都会用类式组件来实现一些较为复杂的组件，函数式组件只能用于实现一些功能简单的组件。原因大概在于，函数式组件只能使用 props(作为函数的参数传入)，而不能像类式组件一样使用 state 和 refs。同时，类式组件还有生命周期钩子，比如常用的 componentDidMount() 和componentWillUnmount()，能够分别在组件挂载后和卸载前执行某些操作，函数式组件也没有。 但是类式组件也有它自身的很多问题，具体可以看React 官方文档，因此 React 在 16.8 版本中新增了 Hook。它可以在不编写 class 的情况下使用 state 以及其他的 React 特性。 Hook 的复杂运用我也不太会，但是还是可以说说最基本的两个 Hook：State Hook 和 Effect Hook。 State HookState Hook 是为了在函数式组件中使用 state 而设计的。以往在类式组件中，我们要用 state 得这么写： 12345678910111213141516import React, { Component } from 'react'export default class test extends Component { state={count:0} changeCount = () =&gt; { console.log(this.state.count) // 获取 count 并输出 this.setState({count:1}) // 修改 count } render() { return ( // ... ) }} 有了 State Hook，就可以这么写： 123456789101112131415import React，{useState} from 'react'export default function test() { const [count, setCount] = useState(0) changeCount = () =&gt; { console.log(count) // 获取 count 并输出 setCount(1) // 修改 count } return ( // ... )} 可以看到，定义 state 只需要 const [count, setCount] = useState(0)。这里用到了数组的解构赋值，具体来说，useState() 的返回值是一个有两个元素的数组，第一个元素就赋值给了 count，第二个元素就赋值给了setCount，要注意的是，这里的setCount 是一个用于修改对应 state 的函数。useState()的参数就是这个 state 的初值，比如这里就是给 count 赋初值 0。 使用 state 时就直接用 count 就行了，不用再麻烦的 this.state.count 了。修改 state 只需要调用该 state 对应的 setXXX() 就行，这里就是setCount(1)，括号里的参数就是要修改成的值。 如果要多个 state，那就多用几次 useState() 就行，每次赋值给不同名称的参数即可。只要记住 state 都是两两成对，修改 state 必须用对应的方法就行。 Effect HookEffect Hook 又叫做副作用钩子，用于在函数组件中实现声明周期钩子的效果。 用法如下： 123456789101112131415161718import React, { useEffect}from 'react'export default function test() { useEffect(() =&gt; { // effect return () =&gt; { // cleanup } }, [input]) return ( &lt;div&gt; &lt;/div&gt; )} useState()一个函数就能实现 componentDidMount() 、componentWillUnmount()、componentDidUpdate(prevProps, prevState) 三个函数的功能。 useState()的参数有两个，第一个是函数，第二个是数组。 写在函数体中的内容效果相当于 componentDidMount() 和componentDidUpdate()，也就是，组件每次更新就会执行一次，包括首次挂载时。函数的返回值也是一个函数，其中的效果与 componentWillUnmount() 相同，会在组件卸载前执行。 然后是第二个数组参数。 前面提到，函数体中的内容首次挂载和每次更新后都会执行，但这样就会有很多不必要的麻烦。比如：我想在函数首次挂载时发送 ajax 请求来获取数据。如果直接写在函数体中，则就会陷入：首次挂载 → 发送请求 → 数据更新 → 组件更新 → 发送请求 → 数据更新 → 组件更新 → … 的死循环。 而数组参数就可以避免这个问题。函数体中的内容，只会在数组中的值更新时才会调用，如果组件更新了但该数组中的元素的值并没有变化，则不会执行函数内容。 具体而言，可以看下面的例子： 12345678910111213141516171819202122232425262728import axios from 'axios'import React, { useState, useEffect } from 'react'export default function HookTest() { const [data, setData] = useState(null) const [count, setCount] = useState(0) async function getData(params) { const data = await axios.get('http://localhost:8080/home/swiper') console.log(data); setData(data.data.body); } // 第二个参数数组中的元素，应该最好是 state，因为只有 state 更新了才会请求重新渲染组件，从而利用第二个参数判断要不要重新渲染， // 如果不是 state，不管怎么修改都不会发起重新渲染的请求，也就没有意义了 // 如果只需要第一次挂载时执行，第二个参数设为[] 即可 useEffect(() =&gt; { getData(); }, [count]) return ( &lt;div&gt; &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt; 点我发送请求&lt;/button&gt; &lt;/div&gt; )} 这个例子就实现了 首次挂载时 以及 点击按钮后 发送请求的功能。 首次挂载必定会发送请求，这没什么好说的。重要的实现点击按钮发送请求且不会因为更新了 data 而更新组件继而又发送请求。 这里用到了名为 count 的 state： 点击按钮 → setCount(count + 1) → 修改了 state 从而更新组件 → 更新后 useEffect() 判断 count 是否和上一次的值相同 → 不同（加了 1），因此执行函数体内容，即发送请求 → 得到新数据，更新 data → data 也是 state，组件再次更新 → 但是这次 count 没变，因此不会再次执行函数体内容。 P.S. 我觉得一般情况下没人会像我上面那么写，正常做法应该是将发送请求单独写在一个函数里，然后在 useState() 第一个参数的函数体里调用一次，第二个参数数组设为[]，然后再单独给按钮的点击事件绑定这个函数。 结尾 还有什么自定义 Hook 之类的进阶用法，我还没学会，以后再说吧。 附：React 官方文档","link":"/2021/11/19/React%E4%B8%ADHook%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"hello hexo","text":"这是用 hexo 搭建博客后写的第一篇博文","link":"/2021/11/15/hello-hexo/"},{"title":"hexo deploy 执行失败的解决方法","text":"为了能上传这篇文章浪费了两个多小时。 问题描述 hexo deploy 突然没法执行成功了，报错如下： 很明显是 git 操作又出了问题，看描述是没有写权限。 百度了半天，全是说用户名密码出了问题，重新设置一下就好。但是一点用都没有。还有说获取个 token 就行的，试了也没用，报错还变了： 总之将近两小时一事无成。 解决方法 换用 ssh，不用 https 了。 首先要获取一个 ssh，教程在这，只要看怎么获取 SSH Key 并绑定到 github 上就行了。 然后复制仓库的 ssh 地址： 再粘贴到 hexo 的 _config.yml 中，位置及格式如下（branch 可有可无）： 然后就 OK 啦，直接 hexo deploy 就行了。","link":"/2021/11/19/hexo-deploy%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"好客租房项目的小笔记 (三)","text":"本文介绍了 react 中使用 onClick={} 绑定事件处理函数的几种情况。 关于 onClick={} 的问题 简单来说，有三种情况： 不需要传参，不需要获取触发事件的元素本身。这时直接写函数名即可，不需要使用箭头函数。 123function f(){}&lt;div onClick={f} /&gt; 切记千万不能写成 onClick={f()}，加了括号就会直接调用且只会调用一次。不加括号意味着是将函数体放在那。 不需要传参，但需要获取触发事件的元素本身。 12345function f(e){ //event.currentTarget 就是绑定的元素本身}&lt;div onClick={(e)=&gt;f(e)} /&gt; 需要注意的是，箭头函数的右侧不要写花括号，f(e) 是返回值，箭头函数只有返回值时可以同时省略 return 和 {} 。 或者也可以直接写成： 123function f(e){}&lt;div onClick={f} /&gt; 需要传参。 1234function f(){}let a=0&lt;div onClick={()=&gt;f(a)} /&gt; 参数的来源暂且不论，一般来说根据函数的闭包直接写 f(a) 即可","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%B8%89/"},{"title":"好客租房项目的小笔记 (一)","text":"本文主要介绍了 ES6 中新增的 async/await 的用法，顺便提及了 promise 的用法。 await 的知识点 await 其实只是替代了promise.then() 方法，但是还是没法省略掉 promise 对象。await 的后面必须跟一个 promise 对象，跟的是函数的话函数的返回值也要是 promise 对象。所以如果异步操作的函数里面没有返回 promise 对象，那还是得自己再包一层函数，将异步操作放在 return 的 promise 对象里才行。 比如 var data=await setTimeout(()={//...}) 是不行的，因为 await 后面跟的不是 promise 对象，需要写成: 12345678async function f3() { var data = await new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('time over') }, 500); }) console.log(data);} 注意 await 要用在函数里面，函数外侧需要有 async;还有就是 promise 内必须要调用 resolve() 或者 reject() 方法 总之, promise 是躲不掉的 原先接 promise 的返回值是要 promise.then((data)=&gt;{ //... }) 这样写就有点麻烦，用了 await 就成了： 12var data=await promise//... 可以看到 data 就直接拿到外面来了，下面再写对 data 的处理，这样看起来就像普通的同步操作一样，这也就是 await 最大的用处。 还有就是，async 函数的返回值是 Promise 对象，也就是说，await 后面可以直接跟一个用 async 修饰的函数。 Promise 对象内部也是单线程的，异步操作也是放在最后执行，所以 resolve() 不能直接写在异步操作外面，这样会先执行 resolve，后进行异步操作，自然会出问题 当然，即使 resolve 了 promise 内部的操作还会继续执行 比如： 1234567891011121314151617181920async function f5() { var data = await new Promise((resolve) =&gt; { data = 0 setTimeout(() =&gt; { console.log(' 异步操作 '); data = 1 }, 300); console.log(' 同步操作 '); resolve(data) }) console.log(' 外部操作 输出 data:', data);}f5() /* 结果：同步操作 外部操作 输出 data: 0异步操作*/ 可以看到首先执行了 promise 内部的同步操作，接着直接 resolve(data) ，外部在 resolve 后获取到了 data 值（未修改的）继续执行，输出了 data，最后 promise 内部的异步操作结束","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%B8%80/"},{"title":"好客租房项目的小笔记 (四)","text":"本文介绍了如何使用正则表达式进行 替换 特定文本。 正则替换 正则表达式除了用于查询之外，还可以用于替换。替换要用到圆括号 () 和 $。 圆括号表示捕获组的意思，本身并不影响匹配，但是在查询时可以实现查找重复内容。比如要查询字符串 abcd123+123efg 中的 123+123 部分，正则表达式可以写成：([0-9]+)\\+\\1 。其中，\\1就代表前面的 ([0-9]+) 匹配到的内容。要注意的是，匹配的是内容而不是正则表达式，也就是说，假如上述字符串为 abcd123+456efg ，那就没法匹配成功，因为 456 和 123 不一样，而 \\1 代表的的是前面的 ([0-9]+) 所匹配到的 123 , 而不是它自身。 接着话题回到替换上。替换基本上也是和上面一样，但是把反斜杠 \\ 换成了 $ , 用于表示要保留的内容（大概）。举个例子，要把 className={styles.mapContainer} 替换成 className='mapContainer' ，查找和替换的正则表达式可以这么写： 12classname=\\{styles.([A-Za-z0-9]+)\\} // 查找className='$1' // 替换 其中的 $1 就代表 ([A-Za-z0-9]+) 所匹配到的内容: mapContainer ，也就是想要保留的部分。要是有多个捕获组，当然也可以用 $2、$3 这类。个人觉得吧，替换的部分可能压根就不能用正则表达式，顶多只能像这样复用一下查找时匹配到的内容吧？ 高软老师的补充： 昨天课后讨论有关捕获组的用法，在匹配时仅适用于重复的字串，比如 219219219 或者 ABC ABC，这样的才能用 \\1 替代捕获组小括号里的匹配结果，在（）+ 这样将捕获组作为一个元素出现 1 次或多次的情况，\\1 代表最后一次匹配结果。 本文其实也用了这种方法替换中英文的逗号：匹配 ([\\u4e00-\\u9fa5]),([\\u4e00-\\u9fa5]) 替换为 $1，$2效果：汉字之间的英文逗号替换为中文逗号","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E5%9B%9B/"},{"title":"好客租房项目的小笔记 (二)","text":"本文主要介绍了 js 中 map() 和forEach()的区别以及为什么 react 要用map()。 关于 React 里面为什么渲染重复组件时用 map() 不用 forEach()首先，arr.map(callback()) 和 arr.forEach(callback()) 都可以遍历数组，二者区别在于，map() 会返回一个新的数组，而 forEach() 则不会。 先看一下项目里的用法吧： 12345678910111213141516171819202122232425renderTabItem() { return tabItems.map((item) =&gt; { return ( &lt;TabBar.Item //... &gt; &lt;/TabBar.Item&gt; ) })}//...render() { return ( &lt;div className=&quot;home&quot;&gt; //... &lt;TabBar&gt; { this.renderTabItem() } &lt;/TabBar&gt; &lt;/div&gt; )}} 以下是个人理解：既然是要渲染 dom 元素，那最后必然要有返回值才行。这里 map() 的回调函数中的 return ，实际上是返回了一个新数组中的一个个元素。也就是说，最后会得到一个元素为 JSX 节点的新数组，然后再经由最外侧的 return 返回给 render() 用于渲染组件（ JSX 会自己把数组中的元素一个个渲染出来）。 如果用 forEach() 的话，没有返回值，所以不行。","link":"/2021/11/15/%E5%A5%BD%E5%AE%A2%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0-%E4%BA%8C/"},{"title":"ES5 中的构造函数与 ES6 中 Class 的关系","text":"众所周知，ES6 中新增的 Class 就是此前的构造函数的语法糖，虽然现在都用 class 很方便，但是面试肯定是会问到构造函数的用法的，因此还是得搞明白。 二者的使用当然是有区别的啦。 构造函数 构造函数和普通函数的区别在于，一般来说，构造函数命名时都是首字母大写的。但这个说到底也只是建议，大小写本身并不会影响函数的性质。任何一个函数，如果使用了new，那它就能实现构造函数的效果，同理，只要不new，首字母大写的函数也能和普通函数一样执行。 1234567function Fn(){ this.name='Fn' console.log(this.name)}Fn()// 控制台输出: Fn 12345678function fn(){ this.name='fn'}var fobj=new fn()console.log(fobj)// 控制台输出: fn {name: &quot;fn&quot;}// 也就是定义了一个 fn 类型的对象 构造函数中，通过 this.xxx 定义成员变量，也就是实例变量，最后会赋值给每一个实例对象。但是测试了一下，构造函数中似乎不能用 static 定义静态变量。静态变量应在函数外部用 FunctionName.xxx=xxx 来定义。 定义成员方法的话，可以直接在函数内部像普通成员变量一样定义，即 this.fn=function(){} 的形式，这样会给每一个实例对象都复制一份这个方法，可能有点浪费空间，因此一般建议放在原型对象上，即 1FunctionName.prototype.xxx=function(){} 这样函数本身就只会有一份，每个实例对象调用该方法时只需查找 原型链 就能找到该方法。 Class Class 的思路其实和上面的一样，只是优化了写法而已。 12345678910111213141516171819202122class Person { constructor(name) { this.name = name; } age=12 // 方式一 say() { console.log('this is say', this); } // 方式二 say2 = function (params) { console.log('this is say2', this); } // 方式三 say3 = () =&gt; { console.log('this is say3', this); }} 上面的代码是从 JS 的 class 中成员方法定义的小细节 中复制过来的，并添加了第 6 行。 可以看到，Class 中多了一个constructor()，学过其他面向对象语言应该很熟悉，这个也叫构造函数。用途其实和之前的构造函数差不多，就是用来初始化成员变量的。 然后是第 6 行的 age=12，class 中，定义成员变量其实也可以不用构造函数，直接写在 class 内，这样也可以省略this 关键词。但是只有 constructor() 的参数能够从外部传入，因此这种写法只能用于初始化不需要从外部获取数据以初始化的成员变量。 成员方法的定义具体可以看JS 的 class 中成员方法定义的小细节，这里就不多赘述了。 new 在执行时会做四件事情： ① 在内存中创建一个新的空对象。 ② 让 this 指向这个新的对象。 ③ 执行构造函数里面的代码，给这个新对象添加属性和方法。 ④ 返回这个新对象（所以构造函数里面不需要 return ）。 顺便，构造函数理论上是用来初始化对象的，也不能 return，因此最好不要在里面写一些过于复杂的逻辑。 但是个人感觉，有的时候也不能太死板。比如要初始化成员变量为数组，且数组内容是 1~999 的数字，总不能呆呆地写个 this.arr=[1,2,3...] 吧？写个循环来初始化也是在所难免的。也不用担心会执行出错，毕竟执行构造函数时和执行普通函数并没有什么区别，无非是自动调用了而已。","link":"/2021/11/28/ES5%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8EES6%E4%B8%ADClass%E7%9A%84%E5%85%B3%E7%B3%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"note","slug":"note","link":"/categories/note/"},{"name":"学习","slug":"note/学习","link":"/categories/note/%E5%AD%A6%E4%B9%A0/"}]}